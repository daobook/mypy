
<!DOCTYPE html>

<html lang="zh_CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Literal types and Enums &#8212; Mypy 0.940+dev.d02f39d1f0317448dbbec1e7a5417a3780c278f2 文档</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/classic.css" />
    
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/translations.js"></script>
    
    <link rel="index" title="索引" href="genindex.html" />
    <link rel="search" title="搜索" href="search.html" />
    <link rel="next" title="Final names, methods and classes" href="final_attrs.html" />
    <link rel="prev" title="More types" href="more_types.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="总目录"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="final_attrs.html" title="Final names, methods and classes"
             accesskey="N">下一页</a> |</li>
        <li class="right" >
          <a href="more_types.html" title="More types"
             accesskey="P">上一页</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Mypy 0.940+dev.d02f39d1f0317448dbbec1e7a5417a3780c278f2 文档</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Literal types and Enums</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="literal-types-and-enums">
<h1>Literal types and Enums<a class="headerlink" href="#literal-types-and-enums" title="永久链接至标题">¶</a></h1>
<section id="literal-types">
<span id="id1"></span><h2>Literal types<a class="headerlink" href="#literal-types" title="永久链接至标题">¶</a></h2>
<p>Literal types let you indicate that an expression is equal to some specific
primitive value. For example, if we annotate a variable with type <code class="docutils literal notranslate"><span class="pre">Literal[&quot;foo&quot;]</span></code>,
mypy will understand that variable is not only of type <code class="docutils literal notranslate"><span class="pre">str</span></code>, but is also
equal to specifically the string <code class="docutils literal notranslate"><span class="pre">&quot;foo&quot;</span></code>.</p>
<p>This feature is primarily useful when annotating functions that behave
differently based on the exact value the caller provides. For example,
suppose we have a function <code class="docutils literal notranslate"><span class="pre">fetch_data(...)</span></code> that returns <code class="docutils literal notranslate"><span class="pre">bytes</span></code> if the
first argument is <code class="docutils literal notranslate"><span class="pre">True</span></code>, and <code class="docutils literal notranslate"><span class="pre">str</span></code> if it’s <code class="docutils literal notranslate"><span class="pre">False</span></code>. We can construct a
precise type signature for this function using <code class="docutils literal notranslate"><span class="pre">Literal[...]</span></code> and overloads:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">overload</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Literal</span>

<span class="c1"># The first two overloads use Literal[...] so we can</span>
<span class="c1"># have precise return types:</span>

<span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">fetch_data</span><span class="p">(</span><span class="n">raw</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">True</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bytes</span><span class="p">:</span> <span class="o">...</span>
<span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">fetch_data</span><span class="p">(</span><span class="n">raw</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">False</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span> <span class="o">...</span>

<span class="c1"># The last overload is a fallback in case the caller</span>
<span class="c1"># provides a regular bool:</span>

<span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">fetch_data</span><span class="p">(</span><span class="n">raw</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bytes</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span> <span class="o">...</span>

<span class="k">def</span> <span class="nf">fetch_data</span><span class="p">(</span><span class="n">raw</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bytes</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
    <span class="c1"># Implementation is omitted</span>
    <span class="o">...</span>

<span class="n">reveal_type</span><span class="p">(</span><span class="n">fetch_data</span><span class="p">(</span><span class="kc">True</span><span class="p">))</span>        <span class="c1"># Revealed type is &quot;bytes&quot;</span>
<span class="n">reveal_type</span><span class="p">(</span><span class="n">fetch_data</span><span class="p">(</span><span class="kc">False</span><span class="p">))</span>       <span class="c1"># Revealed type is &quot;str&quot;</span>

<span class="c1"># Variables declared without annotations will continue to have an</span>
<span class="c1"># inferred type of &#39;bool&#39;.</span>

<span class="n">variable</span> <span class="o">=</span> <span class="kc">True</span>
<span class="n">reveal_type</span><span class="p">(</span><span class="n">fetch_data</span><span class="p">(</span><span class="n">variable</span><span class="p">))</span>    <span class="c1"># Revealed type is &quot;Union[bytes, str]&quot;</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>The examples in this page import <code class="docutils literal notranslate"><span class="pre">Literal</span></code> as well as <code class="docutils literal notranslate"><span class="pre">Final</span></code> and
<code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> from the <code class="docutils literal notranslate"><span class="pre">typing</span></code> module. These types were added to
<code class="docutils literal notranslate"><span class="pre">typing</span></code> in Python 3.8, but are also available for use in Python 2.7
and 3.4 - 3.7 via the <code class="docutils literal notranslate"><span class="pre">typing_extensions</span></code> package.</p>
</div>
<section id="parameterizing-literals">
<h3>Parameterizing Literals<a class="headerlink" href="#parameterizing-literals" title="永久链接至标题">¶</a></h3>
<p>Literal types may contain one or more literal bools, ints, strs, bytes, and
enum values. However, literal types <strong>cannot</strong> contain arbitrary expressions:
types like <code class="docutils literal notranslate"><span class="pre">Literal[my_string.trim()]</span></code>, <code class="docutils literal notranslate"><span class="pre">Literal[x</span> <span class="pre">&gt;</span> <span class="pre">3]</span></code>, or <code class="docutils literal notranslate"><span class="pre">Literal[3j</span> <span class="pre">+</span> <span class="pre">4]</span></code>
are all illegal.</p>
<p>Literals containing two or more values are equivalent to the union of those values.
So, <code class="docutils literal notranslate"><span class="pre">Literal[-3,</span> <span class="pre">b&quot;foo&quot;,</span> <span class="pre">MyEnum.A]</span></code> is equivalent to
<code class="docutils literal notranslate"><span class="pre">Union[Literal[-3],</span> <span class="pre">Literal[b&quot;foo&quot;],</span> <span class="pre">Literal[MyEnum.A]]</span></code>. This makes writing more
complex types involving literals a little more convenient.</p>
<p>Literal types may also contain <code class="docutils literal notranslate"><span class="pre">None</span></code>. Mypy will treat <code class="docutils literal notranslate"><span class="pre">Literal[None]</span></code> as being
equivalent to just <code class="docutils literal notranslate"><span class="pre">None</span></code>. This means that <code class="docutils literal notranslate"><span class="pre">Literal[4,</span> <span class="pre">None]</span></code>,
<code class="docutils literal notranslate"><span class="pre">Union[Literal[4],</span> <span class="pre">None]</span></code>, and <code class="docutils literal notranslate"><span class="pre">Optional[Literal[4]]</span></code> are all equivalent.</p>
<p>Literals may also contain aliases to other literal types. For example, the
following program is legal:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">PrimaryColors</span> <span class="o">=</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;red&quot;</span><span class="p">,</span> <span class="s2">&quot;blue&quot;</span><span class="p">,</span> <span class="s2">&quot;yellow&quot;</span><span class="p">]</span>
<span class="n">SecondaryColors</span> <span class="o">=</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;purple&quot;</span><span class="p">,</span> <span class="s2">&quot;green&quot;</span><span class="p">,</span> <span class="s2">&quot;orange&quot;</span><span class="p">]</span>
<span class="n">AllowedColors</span> <span class="o">=</span> <span class="n">Literal</span><span class="p">[</span><span class="n">PrimaryColors</span><span class="p">,</span> <span class="n">SecondaryColors</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">paint</span><span class="p">(</span><span class="n">color</span><span class="p">:</span> <span class="n">AllowedColors</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span> <span class="o">...</span>

<span class="n">paint</span><span class="p">(</span><span class="s2">&quot;red&quot;</span><span class="p">)</span>        <span class="c1"># Type checks!</span>
<span class="n">paint</span><span class="p">(</span><span class="s2">&quot;turquoise&quot;</span><span class="p">)</span>  <span class="c1"># Does not type check</span>
</pre></div>
</div>
<p>Literals may not contain any other kind of type or expression. This means doing
<code class="docutils literal notranslate"><span class="pre">Literal[my_instance]</span></code>, <code class="docutils literal notranslate"><span class="pre">Literal[Any]</span></code>, <code class="docutils literal notranslate"><span class="pre">Literal[3.14]</span></code>, or
<code class="docutils literal notranslate"><span class="pre">Literal[{&quot;foo&quot;:</span> <span class="pre">2,</span> <span class="pre">&quot;bar&quot;:</span> <span class="pre">5}]</span></code> are all illegal.</p>
</section>
<section id="declaring-literal-variables">
<h3>Declaring literal variables<a class="headerlink" href="#declaring-literal-variables" title="永久链接至标题">¶</a></h3>
<p>You must explicitly add an annotation to a variable to declare that it has
a literal type:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">a</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="mi">19</span><span class="p">]</span> <span class="o">=</span> <span class="mi">19</span>
<span class="n">reveal_type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>          <span class="c1"># Revealed type is &quot;Literal[19]&quot;</span>
</pre></div>
</div>
<p>In order to preserve backwards-compatibility, variables without this annotation
are <strong>not</strong> assumed to be literals:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">b</span> <span class="o">=</span> <span class="mi">19</span>
<span class="n">reveal_type</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>          <span class="c1"># Revealed type is &quot;int&quot;</span>
</pre></div>
</div>
<p>If you find repeating the value of the variable in the type hint to be tedious,
you can instead change the variable to be <code class="docutils literal notranslate"><span class="pre">Final</span></code> (see <a class="reference internal" href="final_attrs.html#final-attrs"><span class="std std-ref">Final names, methods and classes</span></a>):</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Final</span><span class="p">,</span> <span class="n">Literal</span>

<span class="k">def</span> <span class="nf">expects_literal</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="mi">19</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span> <span class="k">pass</span>

<span class="n">c</span><span class="p">:</span> <span class="n">Final</span> <span class="o">=</span> <span class="mi">19</span>

<span class="n">reveal_type</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>          <span class="c1"># Revealed type is &quot;Literal[19]?&quot;</span>
<span class="n">expects_literal</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>      <span class="c1"># ...and this type checks!</span>
</pre></div>
</div>
<p>If you do not provide an explicit type in the <code class="docutils literal notranslate"><span class="pre">Final</span></code>, the type of <code class="docutils literal notranslate"><span class="pre">c</span></code> becomes
<em>context-sensitive</em>: mypy will basically try “substituting” the original assigned
value whenever it’s used before performing type checking. This is why the revealed
type of <code class="docutils literal notranslate"><span class="pre">c</span></code> is <code class="docutils literal notranslate"><span class="pre">Literal[19]?</span></code>: the question mark at the end reflects this
context-sensitive nature.</p>
<p>For example, mypy will type check the above program almost as if it were written like so:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Final</span><span class="p">,</span> <span class="n">Literal</span>

<span class="k">def</span> <span class="nf">expects_literal</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="mi">19</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span> <span class="k">pass</span>

<span class="n">reveal_type</span><span class="p">(</span><span class="mi">19</span><span class="p">)</span>
<span class="n">expects_literal</span><span class="p">(</span><span class="mi">19</span><span class="p">)</span>
</pre></div>
</div>
<p>This means that while changing a variable to be <code class="docutils literal notranslate"><span class="pre">Final</span></code> is not quite the same thing
as adding an explicit <code class="docutils literal notranslate"><span class="pre">Literal[...]</span></code> annotation, it often leads to the same effect
in practice.</p>
<p>The main cases where the behavior of context-sensitive vs true literal types differ are
when you try using those types in places that are not explicitly expecting a <code class="docutils literal notranslate"><span class="pre">Literal[...]</span></code>.
For example, compare and contrast what happens when you try appending these types to a list:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Final</span><span class="p">,</span> <span class="n">Literal</span>

<span class="n">a</span><span class="p">:</span> <span class="n">Final</span> <span class="o">=</span> <span class="mi">19</span>
<span class="n">b</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="mi">19</span><span class="p">]</span> <span class="o">=</span> <span class="mi">19</span>

<span class="c1"># Mypy will choose to infer list[int] here.</span>
<span class="n">list_of_ints</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">list_of_ints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="n">reveal_type</span><span class="p">(</span><span class="n">list_of_ints</span><span class="p">)</span>  <span class="c1"># Revealed type is &quot;list[int]&quot;</span>

<span class="c1"># But if the variable you&#39;re appending is an explicit Literal, mypy</span>
<span class="c1"># will infer list[Literal[19]].</span>
<span class="n">list_of_lits</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">list_of_lits</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="n">reveal_type</span><span class="p">(</span><span class="n">list_of_lits</span><span class="p">)</span>  <span class="c1"># Revealed type is &quot;list[Literal[19]]&quot;</span>
</pre></div>
</div>
</section>
<section id="intelligent-indexing">
<h3>Intelligent indexing<a class="headerlink" href="#intelligent-indexing" title="永久链接至标题">¶</a></h3>
<p>We can use Literal types to more precisely index into structured heterogeneous
types such as tuples, NamedTuples, and TypedDicts. This feature is known as
<em>intelligent indexing</em>.</p>
<p>For example, when we index into a tuple using some int, the inferred type is
normally the union of the tuple item types. However, if we want just the type
corresponding to some particular index, we can use Literal types like so:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">TypedDict</span>

<span class="n">tup</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;foo&quot;</span><span class="p">,</span> <span class="mf">3.4</span><span class="p">)</span>

<span class="c1"># Indexing with an int literal gives us the exact type for that index</span>
<span class="n">reveal_type</span><span class="p">(</span><span class="n">tup</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># Revealed type is &quot;str&quot;</span>

<span class="c1"># But what if we want the index to be a variable? Normally mypy won&#39;t</span>
<span class="c1"># know exactly what the index is and so will return a less precise type:</span>
<span class="n">int_index</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">reveal_type</span><span class="p">(</span><span class="n">tup</span><span class="p">[</span><span class="n">int_index</span><span class="p">])</span>  <span class="c1"># Revealed type is &quot;Union[str, float]&quot;</span>

<span class="c1"># But if we use either Literal types or a Final int, we can gain back</span>
<span class="c1"># the precision we originally had:</span>
<span class="n">lit_index</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">fin_index</span><span class="p">:</span> <span class="n">Final</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">reveal_type</span><span class="p">(</span><span class="n">tup</span><span class="p">[</span><span class="n">lit_index</span><span class="p">])</span>  <span class="c1"># Revealed type is &quot;str&quot;</span>
<span class="n">reveal_type</span><span class="p">(</span><span class="n">tup</span><span class="p">[</span><span class="n">fin_index</span><span class="p">])</span>  <span class="c1"># Revealed type is &quot;str&quot;</span>

<span class="c1"># We can do the same thing with with TypedDict and str keys:</span>
<span class="k">class</span> <span class="nc">MyDict</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">):</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">main_id</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">backup_id</span><span class="p">:</span> <span class="nb">int</span>

<span class="n">d</span><span class="p">:</span> <span class="n">MyDict</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;Saanvi&quot;</span><span class="p">,</span> <span class="s2">&quot;main_id&quot;</span><span class="p">:</span> <span class="mi">111</span><span class="p">,</span> <span class="s2">&quot;backup_id&quot;</span><span class="p">:</span> <span class="mi">222</span><span class="p">}</span>
<span class="n">name_key</span><span class="p">:</span> <span class="n">Final</span> <span class="o">=</span> <span class="s2">&quot;name&quot;</span>
<span class="n">reveal_type</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">name_key</span><span class="p">])</span>  <span class="c1"># Revealed type is &quot;str&quot;</span>

<span class="c1"># You can also index using unions of literals</span>
<span class="n">id_key</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;main_id&quot;</span><span class="p">,</span> <span class="s2">&quot;backup_id&quot;</span><span class="p">]</span>
<span class="n">reveal_type</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">id_key</span><span class="p">])</span>    <span class="c1"># Revealed type is &quot;int&quot;</span>
</pre></div>
</div>
</section>
<section id="tagged-unions">
<span id="id2"></span><h3>Tagged unions<a class="headerlink" href="#tagged-unions" title="永久链接至标题">¶</a></h3>
<p>When you have a union of types, you can normally discriminate between each type
in the union by using <code class="docutils literal notranslate"><span class="pre">isinstance</span></code> checks. For example, if you had a variable <code class="docutils literal notranslate"><span class="pre">x</span></code> of
type <code class="docutils literal notranslate"><span class="pre">Union[int,</span> <span class="pre">str]</span></code>, you could write some code that runs only if <code class="docutils literal notranslate"><span class="pre">x</span></code> is an int
by doing <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">isinstance(x,</span> <span class="pre">int):</span> <span class="pre">...</span></code>.</p>
<p>However, it is not always possible or convenient to do this. For example, it is not
possible to use <code class="docutils literal notranslate"><span class="pre">isinstance</span></code> to distinguish between two different TypedDicts since
at runtime, your variable will simply be just a dict.</p>
<p>Instead, what you can do is <em>label</em> or <em>tag</em> your TypedDicts with a distinct Literal
type. Then, you can discriminate between each kind of TypedDict by checking the label:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Literal</span><span class="p">,</span> <span class="n">TypedDict</span><span class="p">,</span> <span class="n">Union</span>

<span class="k">class</span> <span class="nc">NewJobEvent</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">):</span>
    <span class="n">tag</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;new-job&quot;</span><span class="p">]</span>
    <span class="n">job_name</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">config_file_path</span><span class="p">:</span> <span class="nb">str</span>

<span class="k">class</span> <span class="nc">CancelJobEvent</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">):</span>
    <span class="n">tag</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;cancel-job&quot;</span><span class="p">]</span>
    <span class="n">job_id</span><span class="p">:</span> <span class="nb">int</span>

<span class="n">Event</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="n">NewJobEvent</span><span class="p">,</span> <span class="n">CancelJobEvent</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">process_event</span><span class="p">(</span><span class="n">event</span><span class="p">:</span> <span class="n">Event</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="c1"># Since we made sure both TypedDicts have a key named &#39;tag&#39;, it&#39;s</span>
    <span class="c1"># safe to do &#39;event[&quot;tag&quot;]&#39;. This expression normally has the type</span>
    <span class="c1"># Literal[&quot;new-job&quot;, &quot;cancel-job&quot;], but the check below will narrow</span>
    <span class="c1"># the type to either Literal[&quot;new-job&quot;] or Literal[&quot;cancel-job&quot;].</span>
    <span class="c1">#</span>
    <span class="c1"># This in turns narrows the type of &#39;event&#39; to either NewJobEvent</span>
    <span class="c1"># or CancelJobEvent.</span>
    <span class="k">if</span> <span class="n">event</span><span class="p">[</span><span class="s2">&quot;tag&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;new-job&quot;</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">event</span><span class="p">[</span><span class="s2">&quot;job_name&quot;</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">event</span><span class="p">[</span><span class="s2">&quot;job_id&quot;</span><span class="p">])</span>
</pre></div>
</div>
<p>While this feature is mostly useful when working with TypedDicts, you can also
use the same technique with regular objects, tuples, or namedtuples.</p>
<p>Similarly, tags do not need to be specifically str Literals: they can be any type
you can normally narrow within <code class="docutils literal notranslate"><span class="pre">if</span></code> statements and the like. For example, you
could have your tags be int or Enum Literals or even regular classes you narrow
using <code class="docutils literal notranslate"><span class="pre">isinstance()</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Generic</span><span class="p">,</span> <span class="n">TypeVar</span><span class="p">,</span> <span class="n">Union</span>

<span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Wrapper</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="n">T</span><span class="p">]):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inner</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inner</span> <span class="o">=</span> <span class="n">inner</span>

<span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="n">w</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Wrapper</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">Wrapper</span><span class="p">[</span><span class="nb">str</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="c1"># Doing `if isinstance(w, Wrapper[int])` does not work: isinstance requires</span>
    <span class="c1"># that the second argument always be an *erased* type, with no generics.</span>
    <span class="c1"># This is because generics are a typing-only concept and do not exist at</span>
    <span class="c1"># runtime in a way `isinstance` can always check.</span>
    <span class="c1">#</span>
    <span class="c1"># However, we can side-step this by checking the type of `w.inner` to</span>
    <span class="c1"># narrow `w` itself:</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">w</span><span class="o">.</span><span class="n">inner</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">reveal_type</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>  <span class="c1"># Revealed type is &quot;Wrapper[int]&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">reveal_type</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>  <span class="c1"># Revealed type is &quot;Wrapper[str]&quot;</span>
</pre></div>
</div>
<p>This feature is sometimes called “sum types” or “discriminated union types”
in other programming languages.</p>
</section>
<section id="exhaustiveness-checks">
<h3>Exhaustiveness checks<a class="headerlink" href="#exhaustiveness-checks" title="永久链接至标题">¶</a></h3>
<p>You may want to check that some code covers all possible
<code class="docutils literal notranslate"><span class="pre">Literal</span></code> or <code class="docutils literal notranslate"><span class="pre">Enum</span></code> cases. Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Literal</span>

<span class="n">PossibleValues</span> <span class="o">=</span> <span class="n">Literal</span><span class="p">[</span><span class="s1">&#39;one&#39;</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">validate</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">PossibleValues</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="s1">&#39;one&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">elif</span> <span class="n">x</span> <span class="o">==</span> <span class="s1">&#39;two&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Invalid value: </span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

<span class="k">assert</span> <span class="n">validate</span><span class="p">(</span><span class="s1">&#39;one&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">True</span>
<span class="k">assert</span> <span class="n">validate</span><span class="p">(</span><span class="s1">&#39;two&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">False</span>
</pre></div>
</div>
<p>In the code above, it’s easy to make a mistake. You can
add a new literal value to <code class="docutils literal notranslate"><span class="pre">PossibleValues</span></code> but forget
to handle it in the <code class="docutils literal notranslate"><span class="pre">validate</span></code> function:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">PossibleValues</span> <span class="o">=</span> <span class="n">Literal</span><span class="p">[</span><span class="s1">&#39;one&#39;</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">,</span> <span class="s1">&#39;three&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>Mypy won’t catch that <code class="docutils literal notranslate"><span class="pre">'three'</span></code> is not covered.  If you want mypy to
perform an exhaustiveness check, you need to update your code to use an
<code class="docutils literal notranslate"><span class="pre">assert_never()</span></code> check:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Literal</span><span class="p">,</span> <span class="n">NoReturn</span>

<span class="n">PossibleValues</span> <span class="o">=</span> <span class="n">Literal</span><span class="p">[</span><span class="s1">&#39;one&#39;</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">assert_never</span><span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="n">NoReturn</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NoReturn</span><span class="p">:</span>
    <span class="c1"># This also works at runtime as well</span>
    <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;This code should never be reached, got: </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s1">&#39;</span>

<span class="k">def</span> <span class="nf">validate</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">PossibleValues</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="s1">&#39;one&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">elif</span> <span class="n">x</span> <span class="o">==</span> <span class="s1">&#39;two&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="n">assert_never</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<p>Now if you add a new value to <code class="docutils literal notranslate"><span class="pre">PossibleValues</span></code> but don’t update <code class="docutils literal notranslate"><span class="pre">validate</span></code>,
mypy will spot the error:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">PossibleValues</span> <span class="o">=</span> <span class="n">Literal</span><span class="p">[</span><span class="s1">&#39;one&#39;</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">,</span> <span class="s1">&#39;three&#39;</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">validate</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">PossibleValues</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="s1">&#39;one&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">elif</span> <span class="n">x</span> <span class="o">==</span> <span class="s1">&#39;two&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="c1"># Error: Argument 1 to &quot;assert_never&quot; has incompatible type &quot;Literal[&#39;three&#39;]&quot;;</span>
    <span class="c1"># expected &quot;NoReturn&quot;</span>
    <span class="n">assert_never</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="limitations">
<h3>Limitations<a class="headerlink" href="#limitations" title="永久链接至标题">¶</a></h3>
<p>Mypy will not understand expressions that use variables of type <code class="docutils literal notranslate"><span class="pre">Literal[..]</span></code>
on a deep level. For example, if you have a variable <code class="docutils literal notranslate"><span class="pre">a</span></code> of type <code class="docutils literal notranslate"><span class="pre">Literal[3]</span></code>
and another variable <code class="docutils literal notranslate"><span class="pre">b</span></code> of type <code class="docutils literal notranslate"><span class="pre">Literal[5]</span></code>, mypy will infer that
<code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">+</span> <span class="pre">b</span></code> has type <code class="docutils literal notranslate"><span class="pre">int</span></code>, <strong>not</strong> type <code class="docutils literal notranslate"><span class="pre">Literal[8]</span></code>.</p>
<p>The basic rule is that literal types are treated as just regular subtypes of
whatever type the parameter has. For example, <code class="docutils literal notranslate"><span class="pre">Literal[3]</span></code> is treated as a
subtype of <code class="docutils literal notranslate"><span class="pre">int</span></code> and so will inherit all of <code class="docutils literal notranslate"><span class="pre">int</span></code>’s methods directly. This
means that <code class="docutils literal notranslate"><span class="pre">Literal[3].__add__</span></code> accepts the same arguments and has the same
return type as <code class="docutils literal notranslate"><span class="pre">int.__add__</span></code>.</p>
</section>
</section>
<section id="enums">
<h2>Enums<a class="headerlink" href="#enums" title="永久链接至标题">¶</a></h2>
<p>Mypy has special support for <a class="reference external" href="https://docs.python.org/3/library/enum.html#enum.Enum" title="(在 Python v3.10)"><code class="xref py py-class docutils literal notranslate"><span class="pre">enum.Enum</span></code></a> and its subclasses:
<a class="reference external" href="https://docs.python.org/3/library/enum.html#enum.IntEnum" title="(在 Python v3.10)"><code class="xref py py-class docutils literal notranslate"><span class="pre">enum.IntEnum</span></code></a>, <a class="reference external" href="https://docs.python.org/3/library/enum.html#enum.Flag" title="(在 Python v3.10)"><code class="xref py py-class docutils literal notranslate"><span class="pre">enum.Flag</span></code></a>, <a class="reference external" href="https://docs.python.org/3/library/enum.html#enum.IntFlag" title="(在 Python v3.10)"><code class="xref py py-class docutils literal notranslate"><span class="pre">enum.IntFlag</span></code></a>,
and <code class="xref py py-class docutils literal notranslate"><span class="pre">enum.StrEnum</span></code>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">enum</span> <span class="kn">import</span> <span class="n">Enum</span>

<span class="k">class</span> <span class="nc">Direction</span><span class="p">(</span><span class="n">Enum</span><span class="p">):</span>
    <span class="n">up</span> <span class="o">=</span> <span class="s1">&#39;up&#39;</span>
    <span class="n">down</span> <span class="o">=</span> <span class="s1">&#39;down&#39;</span>

<span class="n">reveal_type</span><span class="p">(</span><span class="n">Direction</span><span class="o">.</span><span class="n">up</span><span class="p">)</span>  <span class="c1"># Revealed type is &quot;Literal[Direction.up]?&quot;</span>
<span class="n">reveal_type</span><span class="p">(</span><span class="n">Direction</span><span class="o">.</span><span class="n">down</span><span class="p">)</span>  <span class="c1"># Revealed type is &quot;Literal[Direction.down]?&quot;</span>
</pre></div>
</div>
<p>You can use enums to annotate types as you would expect:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Movement</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">direction</span><span class="p">:</span> <span class="n">Direction</span><span class="p">,</span> <span class="n">speed</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">direction</span> <span class="o">=</span> <span class="n">direction</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">speed</span> <span class="o">=</span> <span class="n">speed</span>

<span class="n">Movement</span><span class="p">(</span><span class="n">Direction</span><span class="o">.</span><span class="n">up</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">)</span>  <span class="c1"># ok</span>
<span class="n">Movement</span><span class="p">(</span><span class="s1">&#39;up&#39;</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">)</span>  <span class="c1"># E: Argument 1 to &quot;Movemement&quot; has incompatible type &quot;str&quot;; expected &quot;Direction&quot;</span>
</pre></div>
</div>
<section id="exhaustive-checks">
<h3>Exhaustive checks<a class="headerlink" href="#exhaustive-checks" title="永久链接至标题">¶</a></h3>
<p>Similiar to <code class="docutils literal notranslate"><span class="pre">Literal</span></code> types <code class="docutils literal notranslate"><span class="pre">Enum</span></code> supports exhaustive checks.
Let’s start with a definition:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">enum</span> <span class="kn">import</span> <span class="n">Enum</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">NoReturn</span>

<span class="k">def</span> <span class="nf">assert_never</span><span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="n">NoReturn</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NoReturn</span><span class="p">:</span>
    <span class="c1"># This also works in runtime as well:</span>
    <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="s1">&#39;This code should never be reached, got: </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Direction</span><span class="p">(</span><span class="n">Enum</span><span class="p">):</span>
    <span class="n">up</span> <span class="o">=</span> <span class="s1">&#39;up&#39;</span>
    <span class="n">down</span> <span class="o">=</span> <span class="s1">&#39;down&#39;</span>
</pre></div>
</div>
<p>Now, let’s define an exhaustive check:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">choose_direction</span><span class="p">(</span><span class="n">direction</span><span class="p">:</span> <span class="n">Direction</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">direction</span> <span class="ow">is</span> <span class="n">Direction</span><span class="o">.</span><span class="n">up</span><span class="p">:</span>
        <span class="n">reveal_type</span><span class="p">(</span><span class="n">direction</span><span class="p">)</span>  <span class="c1"># N: Revealed type is &quot;Literal[ex.Direction.up]&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Going up!&#39;</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="k">elif</span> <span class="n">direction</span> <span class="ow">is</span> <span class="n">Direction</span><span class="o">.</span><span class="n">down</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Down&#39;</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="n">assert_never</span><span class="p">(</span><span class="n">direction</span><span class="p">)</span>
</pre></div>
</div>
<p>And then test that it raises an error when some cases are not covered:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">choose_direction</span><span class="p">(</span><span class="n">direction</span><span class="p">:</span> <span class="n">Direction</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">direction</span> <span class="o">==</span> <span class="n">Direction</span><span class="o">.</span><span class="n">up</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Going up!&#39;</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="n">assert_never</span><span class="p">(</span><span class="n">direction</span><span class="p">)</span>  <span class="c1"># E: Argument 1 to &quot;assert_never&quot; has incompatible type &quot;Direction&quot;; expected &quot;NoReturn&quot;</span>
</pre></div>
</div>
</section>
<section id="extra-enum-checks">
<h3>Extra Enum checks<a class="headerlink" href="#extra-enum-checks" title="永久链接至标题">¶</a></h3>
<p>Mypy also tries to support special features of <code class="docutils literal notranslate"><span class="pre">Enum</span></code>
the same way Python’s runtime does.</p>
<p>Extra checks:</p>
<ul>
<li><p>Any <code class="docutils literal notranslate"><span class="pre">Enum</span></code> class with values is implicitly <a class="reference internal" href="final_attrs.html#final-attrs"><span class="std std-ref">final</span></a>.
This is what happens in CPython:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">AllDirection</span><span class="p">(</span><span class="n">Direction</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">left</span> <span class="o">=</span> <span class="s1">&#39;left&#39;</span>
<span class="gp">... </span>    <span class="n">right</span> <span class="o">=</span> <span class="s1">&#39;right&#39;</span>
<span class="gt">Traceback (most recent call last):</span>
  <span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">Other: cannot extend enumeration &#39;Some&#39;</span>
</pre></div>
</div>
<p>We do the same thing:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">AllDirection</span><span class="p">(</span><span class="n">Direction</span><span class="p">):</span>  <span class="c1"># E: Cannot inherit from final class &quot;Some&quot;</span>
    <span class="n">left</span> <span class="o">=</span> <span class="s1">&#39;left&#39;</span>
    <span class="n">right</span> <span class="o">=</span> <span class="s1">&#39;right&#39;</span>
</pre></div>
</div>
</li>
<li><p>All <code class="docutils literal notranslate"><span class="pre">Enum</span></code> fields are implictly <code class="docutils literal notranslate"><span class="pre">final</span></code> as well.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">Direction</span><span class="o">.</span><span class="n">up</span> <span class="o">=</span> <span class="s1">&#39;^&#39;</span>  <span class="c1"># E: Cannot assign to final attribute &quot;up&quot;</span>
</pre></div>
</div>
</li>
<li><p>All field names are checked to be unique.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Some</span><span class="p">(</span><span class="n">Enum</span><span class="p">):</span>
   <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span>
   <span class="n">x</span> <span class="o">=</span> <span class="mi">2</span>  <span class="c1"># E: Attempted to reuse member name &quot;x&quot; in Enum definition &quot;Some&quot;</span>
</pre></div>
</div>
</li>
<li><p>Base classes have no conflicts and mixin types are correct.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">WrongEnum</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="n">enum</span><span class="o">.</span><span class="n">Enum</span><span class="p">):</span>
    <span class="c1"># E: Only a single data type mixin is allowed for Enum subtypes, found extra &quot;int&quot;</span>
    <span class="o">...</span>

<span class="k">class</span> <span class="nc">MixinAfterEnum</span><span class="p">(</span><span class="n">enum</span><span class="o">.</span><span class="n">Enum</span><span class="p">,</span> <span class="n">Mixin</span><span class="p">):</span> <span class="c1"># E: No base classes are allowed after &quot;enum.Enum&quot;</span>
    <span class="o">...</span>
</pre></div>
</div>
</li>
</ul>
</section>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="index.html">目录</a></h3>
    <ul>
<li><a class="reference internal" href="#">Literal types and Enums</a><ul>
<li><a class="reference internal" href="#literal-types">Literal types</a><ul>
<li><a class="reference internal" href="#parameterizing-literals">Parameterizing Literals</a></li>
<li><a class="reference internal" href="#declaring-literal-variables">Declaring literal variables</a></li>
<li><a class="reference internal" href="#intelligent-indexing">Intelligent indexing</a></li>
<li><a class="reference internal" href="#tagged-unions">Tagged unions</a></li>
<li><a class="reference internal" href="#exhaustiveness-checks">Exhaustiveness checks</a></li>
<li><a class="reference internal" href="#limitations">Limitations</a></li>
</ul>
</li>
<li><a class="reference internal" href="#enums">Enums</a><ul>
<li><a class="reference internal" href="#exhaustive-checks">Exhaustive checks</a></li>
<li><a class="reference internal" href="#extra-enum-checks">Extra Enum checks</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>上一个主题</h4>
    <p class="topless"><a href="more_types.html"
                          title="上一章">More types</a></p>
  </div>
  <div>
    <h4>下一个主题</h4>
    <p class="topless"><a href="final_attrs.html"
                          title="下一章">Final names, methods and classes</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>本页</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/literal_types.rst.txt"
            rel="nofollow">显示源代码</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">快速搜索</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="转向" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="总目录"
             >索引</a></li>
        <li class="right" >
          <a href="final_attrs.html" title="Final names, methods and classes"
             >下一页</a> |</li>
        <li class="right" >
          <a href="more_types.html" title="More types"
             >上一页</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Mypy 0.940+dev.d02f39d1f0317448dbbec1e7a5417a3780c278f2 文档</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Literal types and Enums</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; 版权所有 2016, Jukka Lehtosalo.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.4.0.
    </div>
  </body>
</html>