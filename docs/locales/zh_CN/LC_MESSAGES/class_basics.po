# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2016, Jukka Lehtosalo
# This file is distributed under the same license as the Mypy package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Mypy "
"0.940+dev.ff5f71d674aece3095b7a623cc910e48c5a01c1e.dirty\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-03-04 14:39+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"

#: ../../source/class_basics.rst:2
msgid "Class basics"
msgstr ""

#: ../../source/class_basics.rst:4
msgid ""
"This section will help get you started annotating your classes. Built-in "
"classes such as ``int`` also follow these same rules."
msgstr ""

#: ../../source/class_basics.rst:9
msgid "Instance and class attributes"
msgstr ""

#: ../../source/class_basics.rst:11
msgid ""
"The mypy type checker detects if you are trying to access a missing "
"attribute, which is a very common programming error. For this to work "
"correctly, instance and class attributes must be defined or initialized "
"within the class. Mypy infers the types of attributes:"
msgstr ""

#: ../../source/class_basics.rst:26
msgid ""
"This is a bit like each class having an implicitly defined "
":py:data:`__slots__ <object.__slots__>` attribute. This is only enforced "
"during type checking and not when your program is running."
msgstr ""

#: ../../source/class_basics.rst:30
msgid ""
"You can declare types of variables in the class body explicitly using a "
"type annotation:"
msgstr ""

#: ../../source/class_basics.rst:41
msgid ""
"As in Python generally, a variable defined in the class body can be used "
"as a class or an instance variable. (As discussed in the next section, "
"you can override this with a :py:data:`~typing.ClassVar` annotation.)"
msgstr ""

#: ../../source/class_basics.rst:45
msgid ""
"Type comments work as well, if you need to support Python versions "
"earlier than 3.6:"
msgstr ""

#: ../../source/class_basics.rst:53
msgid ""
"Note that attribute definitions in the class body that use a type comment"
" are special: a ``None`` value is valid as the initializer, even though "
"the declared type is not optional. This should be used sparingly, as this"
" can result in ``None``-related runtime errors that mypy can't detect."
msgstr ""

#: ../../source/class_basics.rst:58
msgid ""
"Similarly, you can give explicit types to instance variables defined in a"
" method:"
msgstr ""

#: ../../source/class_basics.rst:70
msgid ""
"You can only define an instance variable within a method if you assign to"
" it explicitly using ``self``:"
msgstr ""

#: ../../source/class_basics.rst:82
msgid "Annotating __init__ methods"
msgstr ""

#: ../../source/class_basics.rst:84
msgid ""
"The :py:meth:`__init__ <object.__init__>` method is somewhat special -- "
"it doesn't return a value.  This is best expressed as ``-> None``.  "
"However, since many feel this is redundant, it is allowed to omit the "
"return type declaration on :py:meth:`__init__ <object.__init__>` methods "
"**if at least one argument is annotated**.  For example, in the following"
" classes :py:meth:`__init__ <object.__init__>` is considered fully "
"annotated:"
msgstr ""

#: ../../source/class_basics.rst:101
msgid ""
"However, if :py:meth:`__init__ <object.__init__>` has no annotated "
"arguments and no return type annotation, it is considered an untyped "
"method:"
msgstr ""

#: ../../source/class_basics.rst:112
msgid "Class attribute annotations"
msgstr ""

#: ../../source/class_basics.rst:114
msgid ""
"You can use a :py:data:`ClassVar[t] <typing.ClassVar>` annotation to "
"explicitly declare that a particular attribute should not be set on "
"instances:"
msgstr ""

#: ../../source/class_basics.rst:130
msgid ""
"It's not necessary to annotate all class variables using "
":py:data:`~typing.ClassVar`. An attribute without the "
":py:data:`~typing.ClassVar` annotation can still be used as a class "
"variable. However, mypy won't prevent it from being used as an instance "
"variable, as discussed previously:"
msgstr ""

#: ../../source/class_basics.rst:145
msgid ""
"Note that :py:data:`~typing.ClassVar` is not a class, and you can't use "
"it with :py:func:`isinstance` or :py:func:`issubclass`. It does not "
"change Python runtime behavior -- it's only for type checkers such as "
"mypy (and also helpful for human readers)."
msgstr ""

#: ../../source/class_basics.rst:150
msgid ""
"You can also omit the square brackets and the variable type in a "
":py:data:`~typing.ClassVar` annotation, but this might not do what you'd "
"expect:"
msgstr ""

#: ../../source/class_basics.rst:158
msgid ""
"In this case the type of the attribute will be implicitly ``Any``. This "
"behavior will change in the future, since it's surprising."
msgstr ""

#: ../../source/class_basics.rst:162
msgid ""
"A :py:data:`~typing.ClassVar` type parameter cannot include type "
"variables: ``ClassVar[T]`` and ``ClassVar[list[T]]`` are both invalid if "
"``T`` is a type variable (see :ref:`generic-classes` for more about type "
"variables)."
msgstr ""

#: ../../source/class_basics.rst:168
msgid "Overriding statically typed methods"
msgstr ""

#: ../../source/class_basics.rst:170
msgid ""
"When overriding a statically typed method, mypy checks that the override "
"has a compatible signature:"
msgstr ""

#: ../../source/class_basics.rst:201
msgid ""
"You can also vary return types **covariantly** in overriding. For "
"example, you could override the return type ``Iterable[int]`` with a "
"subtype such as ``list[int]``. Similarly, you can vary argument types "
"**contravariantly** -- subclasses can have more general argument types."
msgstr ""

#: ../../source/class_basics.rst:206
msgid ""
"You can also override a statically typed method with a dynamically typed "
"one. This allows dynamically typed code to override methods defined in "
"library classes without worrying about their type signatures."
msgstr ""

#: ../../source/class_basics.rst:211
msgid ""
"As always, relying on dynamically typed code can be unsafe. There is no "
"runtime enforcement that the method override returns a value that is "
"compatible with the original return type, since annotations have no "
"effect at runtime:"
msgstr ""

#: ../../source/class_basics.rst:227
msgid "Abstract base classes and multiple inheritance"
msgstr ""

#: ../../source/class_basics.rst:229
msgid ""
"Mypy supports Python :doc:`abstract base classes <library/abc>` (ABCs). "
"Abstract classes have at least one abstract method or property that must "
"be implemented by any *concrete* (non-abstract) subclass. You can define "
"abstract base classes using the :py:class:`abc.ABCMeta` metaclass and the"
" :py:func:`@abc.abstractmethod <abc.abstractmethod>` function decorator. "
"Example:"
msgstr ""

#: ../../source/class_basics.rst:260
msgid ""
"In Python 2.7 you have to use :py:func:`@abc.abstractproperty "
"<abc.abstractproperty>` to define an abstract property."
msgstr ""

#: ../../source/class_basics.rst:263
msgid ""
"Note that mypy performs checking for unimplemented abstract methods even "
"if you omit the :py:class:`~abc.ABCMeta` metaclass. This can be useful if"
" the metaclass would cause runtime metaclass conflicts."
msgstr ""

#: ../../source/class_basics.rst:267
msgid ""
"Since you can't create instances of ABCs, they are most commonly used in "
"type annotations. For example, this method accepts arbitrary iterables "
"containing arbitrary animals (instances of concrete ``Animal`` "
"subclasses):"
msgstr ""

#: ../../source/class_basics.rst:278
msgid ""
"There is one important peculiarity about how ABCs work in Python -- "
"whether a particular class is abstract or not is somewhat implicit. In "
"the example below, ``Derived`` is treated as an abstract base class since"
" ``Derived`` inherits an abstract ``f`` method from ``Base`` and doesn't "
"explicitly implement it. The definition of ``Derived`` generates no "
"errors from mypy, since it's a valid ABC:"
msgstr ""

#: ../../source/class_basics.rst:297
msgid "Attempting to create an instance of ``Derived`` will be rejected, however:"
msgstr ""

#: ../../source/class_basics.rst:306
msgid ""
"It's a common error to forget to implement an abstract method. As shown "
"above, the class definition will not generate an error in this case, but "
"any attempt to construct an instance will be flagged as an error."
msgstr ""

#: ../../source/class_basics.rst:311
msgid ""
"A class can inherit any number of classes, both abstract and concrete. As"
" with normal overrides, a dynamically typed method can override or "
"implement a statically typed method defined in any base class, including "
"an abstract method defined in an abstract base class."
msgstr ""

#: ../../source/class_basics.rst:316
msgid ""
"You can implement an abstract property using either a normal property or "
"an instance variable."
msgstr ""

#: ../../source/class_basics.rst:320
msgid "Slots"
msgstr ""

#: ../../source/class_basics.rst:322
msgid ""
"When a class has explicitly defined `__slots__ "
"<https://docs.python.org/3/reference/datamodel.html#slots>`_, mypy will "
"check that all attributes assigned to are members of ``__slots__``:"
msgstr ""

#: ../../source/class_basics.rst:339
msgid ""
"Mypy will only check attribute assignments against ``__slots__`` when the"
" following conditions hold:"
msgstr ""

#: ../../source/class_basics.rst:342
msgid ""
"All base classes (except builtin ones) must have explicit ``__slots__`` "
"defined (this mirrors Python semantics)."
msgstr ""

#: ../../source/class_basics.rst:345
msgid ""
"``__slots__`` does not include ``__dict__``. If ``__slots__`` includes "
"``__dict__``, arbitrary attributes can be set, similar to when "
"``__slots__`` is not defined (this mirrors Python semantics)."
msgstr ""

#: ../../source/class_basics.rst:349
msgid "All values in ``__slots__`` must be string literals."
msgstr ""

