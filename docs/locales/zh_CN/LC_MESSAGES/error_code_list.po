# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2016, Jukka Lehtosalo
# This file is distributed under the same license as the Mypy package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Mypy "
"0.940+dev.ff5f71d674aece3095b7a623cc910e48c5a01c1e.dirty\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-03-04 14:39+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"

#: ../../source/error_code_list.rst:4
msgid "Error codes enabled by default"
msgstr ""

#: ../../source/error_code_list.rst:6
msgid ""
"This section documents various errors codes that mypy can generate with "
"default options. See :ref:`error-codes` for general documentation about "
"error codes. :ref:`error-codes-optional` documents additional error codes"
" that you can enable."
msgstr ""

#: ../../source/error_code_list.rst:12
msgid "Check that attribute exists [attr-defined]"
msgstr ""

#: ../../source/error_code_list.rst:14
msgid ""
"Mypy checks that an attribute is defined in the target class or module "
"when using the dot operator. This applies to both getting and setting an "
"attribute. New attributes are defined by assignments in the class body, "
"or assignments to ``self.x`` in methods. These assignments don't generate"
" ``attr-defined`` errors."
msgstr ""

#: ../../source/error_code_list.rst:20 ../../source/error_code_list.rst:54
#: ../../source/error_code_list.rst:98 ../../source/error_code_list.rst:116
#: ../../source/error_code_list.rst:137 ../../source/error_code_list.rst:239
#: ../../source/error_code_list.rst:269 ../../source/error_code_list.rst:295
#: ../../source/error_code_list.rst:309 ../../source/error_code_list.rst:331
#: ../../source/error_code_list.rst:354 ../../source/error_code_list.rst:368
#: ../../source/error_code_list.rst:389 ../../source/error_code_list.rst:403
#: ../../source/error_code_list.rst:420 ../../source/error_code_list.rst:479
#: ../../source/error_code_list.rst:500 ../../source/error_code_list.rst:548
#: ../../source/error_code_list.rst:606
msgid "Example:"
msgstr ""

#: ../../source/error_code_list.rst:33
msgid ""
"This error code is also generated if an imported name is not defined in "
"the module in a ``from ... import`` statement (as long as the target "
"module can be found):"
msgstr ""

#: ../../source/error_code_list.rst:42
msgid ""
"A reference to a missing attribute is given the ``Any`` type. In the "
"above example, the type of ``non_existent`` will be ``Any``, which can be"
" important if you silence the error."
msgstr ""

#: ../../source/error_code_list.rst:47
msgid "Check that attribute exists in each union item [union-attr]"
msgstr ""

#: ../../source/error_code_list.rst:49
msgid ""
"If you access the attribute of a value with a union type, mypy checks "
"that the attribute is defined for *every* type in that union. Otherwise "
"the operation can fail at runtime. This also applies to optional types."
msgstr ""

#: ../../source/error_code_list.rst:74
msgid ""
"You can often work around these errors by using ``assert isinstance(obj, "
"ClassName)`` or ``assert obj is not None`` to tell mypy that you know "
"that the type is more specific than what mypy thinks."
msgstr ""

#: ../../source/error_code_list.rst:79
msgid "Check that name is defined [name-defined]"
msgstr ""

#: ../../source/error_code_list.rst:81
msgid ""
"Mypy expects that all references to names have a corresponding definition"
" in an active scope, such as an assignment, function definition or an "
"import. This can catch missing definitions, missing imports, and typos."
msgstr ""

#: ../../source/error_code_list.rst:86
msgid "This example accidentally calls ``sort()`` instead of :py:func:`sorted`:"
msgstr ""

#: ../../source/error_code_list.rst:93
msgid "Check arguments in calls [call-arg]"
msgstr ""

#: ../../source/error_code_list.rst:95
msgid ""
"Mypy expects that the number and names of arguments match the called "
"function. Note that argument type checks have a separate error code "
"``arg-type``."
msgstr ""

#: ../../source/error_code_list.rst:111
msgid "Check argument types [arg-type]"
msgstr ""

#: ../../source/error_code_list.rst:113
msgid ""
"Mypy checks that argument types in a call match the declared argument "
"types in the signature of the called function (if one exists)."
msgstr ""

#: ../../source/error_code_list.rst:131
msgid "Check calls to overloaded functions [call-overload]"
msgstr ""

#: ../../source/error_code_list.rst:133
msgid ""
"When you call an overloaded function, mypy checks that at least one of "
"the signatures of the overload items match the argument types in the "
"call."
msgstr ""

#: ../../source/error_code_list.rst:162
msgid "Check validity of types [valid-type]"
msgstr ""

#: ../../source/error_code_list.rst:164
msgid ""
"Mypy checks that each type annotation and any expression that represents "
"a type is a valid type. Examples of valid types include classes, union "
"types, callable types, type aliases, and literal types. Examples of "
"invalid types include bare integer literals, functions, variables, and "
"modules."
msgstr ""

#: ../../source/error_code_list.rst:170
msgid "This example incorrectly uses the function ``log`` as a type:"
msgstr ""

#: ../../source/error_code_list.rst:182
msgid "You can use :py:data:`~typing.Callable` as the type for callable objects:"
msgstr ""

#: ../../source/error_code_list.rst:194
msgid "Require annotation if variable type is unclear [var-annotated]"
msgstr ""

#: ../../source/error_code_list.rst:196
msgid ""
"In some cases mypy can't infer the type of a variable without an explicit"
" annotation. Mypy treats this as an error. This typically happens when "
"you initialize a variable with an empty collection or ``None``.  If mypy "
"can't infer the collection item type, mypy replaces any parts of the type"
" it couldn't infer with ``Any`` and generates an error."
msgstr ""

#: ../../source/error_code_list.rst:203
msgid "Example with an error:"
msgstr ""

#: ../../source/error_code_list.rst:215
msgid "To address this, we add an explicit annotation:"
msgstr ""

#: ../../source/error_code_list.rst:226
msgid "Check validity of overrides [override]"
msgstr ""

#: ../../source/error_code_list.rst:228
msgid ""
"Mypy checks that an overridden method or attribute is compatible with the"
" base class.  A method in a subclass must accept all arguments that the "
"base class method accepts, and the return type must conform to the return"
" type in the base class (Liskov substitution principle)."
msgstr ""

#: ../../source/error_code_list.rst:233
msgid ""
"Argument types can be more general is a subclass (i.e., they can vary "
"contravariantly).  The return type can be narrowed in a subclass (i.e., "
"it can vary covariantly).  It's okay to define additional arguments in a "
"subclass method, as long all extra arguments have default values or can "
"be left out (``*args``, for example)."
msgstr ""

#: ../../source/error_code_list.rst:262
msgid "Check that function returns a value [return]"
msgstr ""

#: ../../source/error_code_list.rst:264
msgid ""
"If a function has a non-``None`` return type, mypy expects that the "
"function always explicitly returns a value (or raises an exception). The "
"function should not fall off the end of the function, since this is often"
" a bug."
msgstr ""

#: ../../source/error_code_list.rst:290
msgid "Check that return value is compatible [return-value]"
msgstr ""

#: ../../source/error_code_list.rst:292
msgid ""
"Mypy checks that the returned value is compatible with the type signature"
" of the function."
msgstr ""

#: ../../source/error_code_list.rst:304
msgid "Check types in assignment statement [assignment]"
msgstr ""

#: ../../source/error_code_list.rst:306
msgid ""
"Mypy checks that the assigned expression is compatible with the "
"assignment target (or targets)."
msgstr ""

#: ../../source/error_code_list.rst:326
msgid "Check type variable values [type-var]"
msgstr ""

#: ../../source/error_code_list.rst:328
msgid ""
"Mypy checks that value of a type variable is compatible with a value "
"restriction or the upper bound type."
msgstr ""

#: ../../source/error_code_list.rst:348
msgid "Check uses of various operators [operator]"
msgstr ""

#: ../../source/error_code_list.rst:350
msgid ""
"Mypy checks that operands support a binary or unary operation, such as "
"``+`` or ``~``. Indexing operations are so common that they have their "
"own error code ``index`` (see below)."
msgstr ""

#: ../../source/error_code_list.rst:362
msgid "Check indexing operations [index]"
msgstr ""

#: ../../source/error_code_list.rst:364
msgid ""
"Mypy checks that the indexed value in indexing operation such as ``x[y]``"
" supports indexing, and that the index expression has a valid type."
msgstr ""

#: ../../source/error_code_list.rst:383
msgid "Check list items [list-item]"
msgstr ""

#: ../../source/error_code_list.rst:385
msgid ""
"When constructing a list using ``[item, ...]``, mypy checks that each "
"item is compatible with the list type that is inferred from the "
"surrounding context."
msgstr ""

#: ../../source/error_code_list.rst:397
msgid "Check dict items [dict-item]"
msgstr ""

#: ../../source/error_code_list.rst:399
msgid ""
"When constructing a dictionary using ``{key: value, ...}`` or "
"``dict(key=value, ...)``, mypy checks that each key and value is "
"compatible with the dictionary type that is inferred from the surrounding"
" context."
msgstr ""

#: ../../source/error_code_list.rst:411
msgid "Check TypedDict items [typeddict-item]"
msgstr ""

#: ../../source/error_code_list.rst:413
msgid ""
"When constructing a ``TypedDict`` object, mypy checks that each key and "
"value is compatible with the ``TypedDict`` type that is inferred from the"
" surrounding context."
msgstr ""

#: ../../source/error_code_list.rst:416
msgid ""
"When getting a ``TypedDict`` item, mypy checks that the key exists. When "
"assigning to a ``TypedDict``, mypy checks that both the key and the value"
" are valid."
msgstr ""

#: ../../source/error_code_list.rst:435
msgid "Check that type of target is known [has-type]"
msgstr ""

#: ../../source/error_code_list.rst:437
msgid ""
"Mypy sometimes generates an error when it hasn't inferred any type for a "
"variable being referenced. This can happen for references to variables "
"that are initialized later in the source file, and for references across "
"modules that form an import cycle. When this happens, the reference gets "
"an implicit ``Any`` type."
msgstr ""

#: ../../source/error_code_list.rst:443
msgid "In this example the definitions of ``x`` and ``y`` are circular:"
msgstr ""

#: ../../source/error_code_list.rst:455
msgid ""
"To work around this error, you can add an explicit type annotation to the"
" target variable or attribute. Sometimes you can also reorganize the code"
" so that the definition of the variable is placed earlier than the "
"reference to the variable in a source file. Untangling cyclic imports may"
" also help."
msgstr ""

#: ../../source/error_code_list.rst:461
msgid ""
"We add an explicit annotation to the ``y`` attribute to work around the "
"issue:"
msgstr ""

#: ../../source/error_code_list.rst:474
msgid "Check that import target can be found [import]"
msgstr ""

#: ../../source/error_code_list.rst:476
msgid ""
"Mypy generates an error if it can't find the source code or a stub file "
"for an imported module."
msgstr ""

#: ../../source/error_code_list.rst:486
msgid "See :ref:`ignore-missing-imports` for how to work around these errors."
msgstr ""

#: ../../source/error_code_list.rst:489
msgid "Check that each name is defined once [no-redef]"
msgstr ""

#: ../../source/error_code_list.rst:491
msgid ""
"Mypy may generate an error if you have multiple definitions for a name in"
" the same namespace.  The reason is that this is often an error, as the "
"second definition may overwrite the first one. Also, mypy often can't be "
"able to determine whether references point to the first or the second "
"definition, which would compromise type checking."
msgstr ""

#: ../../source/error_code_list.rst:497
msgid ""
"If you silence this error, all references to the defined name refer to "
"the *first* definition."
msgstr ""

#: ../../source/error_code_list.rst:515
msgid "Check that called function returns a value [func-returns-value]"
msgstr ""

#: ../../source/error_code_list.rst:517
msgid ""
"Mypy reports an error if you call a function with a ``None`` return type "
"and don't ignore the return value, as this is usually (but not always) a "
"programming error."
msgstr ""

#: ../../source/error_code_list.rst:521
msgid ""
"In this example, the ``if f()`` check is always false since ``f`` returns"
" ``None``:"
msgstr ""

#: ../../source/error_code_list.rst:537
msgid "Check instantiation of abstract classes [abstract]"
msgstr ""

#: ../../source/error_code_list.rst:539
msgid ""
"Mypy generates an error if you try to instantiate an abstract base class "
"(ABC). An abstract base class is a class with at least one abstract "
"method or attribute. (See also :py:mod:`abc` module documentation)"
msgstr ""

#: ../../source/error_code_list.rst:543
msgid ""
"Sometimes a class is made accidentally abstract, often due to an "
"unimplemented abstract method. In a case like this you need to provide an"
" implementation for the method to make the class concrete (non-abstract)."
msgstr ""

#: ../../source/error_code_list.rst:568
msgid "Check the target of NewType [valid-newtype]"
msgstr ""

#: ../../source/error_code_list.rst:570
msgid ""
"The target of a :py:func:`NewType <typing.NewType>` definition must be a "
"class type. It can't be a union type, ``Any``, or various other special "
"types."
msgstr ""

#: ../../source/error_code_list.rst:573
msgid ""
"You can also get this error if the target has been imported from a module"
" whose source mypy cannot find, since any such definitions are treated by"
" mypy as values with ``Any`` types. Example:"
msgstr ""

#: ../../source/error_code_list.rst:587
msgid ""
"To work around the issue, you can either give mypy access to the sources "
"for ``acme`` or create a stub file for the module.  See :ref:`ignore-"
"missing-imports` for more information."
msgstr ""

#: ../../source/error_code_list.rst:592
msgid "Check the return type of __exit__ [exit-return]"
msgstr ""

#: ../../source/error_code_list.rst:594
msgid ""
"If mypy can determine that :py:meth:`__exit__ <object.__exit__>` always "
"returns ``False``, mypy checks that the return type is *not* ``bool``.  "
"The boolean value of the return type affects which lines mypy thinks are "
"reachable after a ``with`` statement, since any :py:meth:`__exit__ "
"<object.__exit__>` method that can return ``True`` may swallow "
"exceptions. An imprecise return type can result in mysterious errors "
"reported near ``with`` statements."
msgstr ""

#: ../../source/error_code_list.rst:601
msgid ""
"To fix this, use either ``typing_extensions.Literal[False]`` or ``None`` "
"as the return type. Returning ``None`` is equivalent to returning "
"``False`` in this context, since both are treated as false values."
msgstr ""

#: ../../source/error_code_list.rst:616
msgid "This produces the following output from mypy:"
msgstr ""

#: ../../source/error_code_list.rst:626
msgid "You can use ``Literal[False]`` to fix the error:"
msgstr ""

#: ../../source/error_code_list.rst:638
msgid "You can also use ``None``:"
msgstr ""

#: ../../source/error_code_list.rst:648
msgid "Check that naming is consistent [name-match]"
msgstr ""

#: ../../source/error_code_list.rst:650
msgid ""
"The definition of a named tuple or a TypedDict must be named consistently"
" when using the call-based syntax. Example:"
msgstr ""

#: ../../source/error_code_list.rst:661
msgid "Check that overloaded functions have an implementation [no-overload-impl]"
msgstr ""

#: ../../source/error_code_list.rst:663
msgid ""
"Overloaded functions outside of stub files must be followed by a non "
"overloaded implementation."
msgstr ""

#: ../../source/error_code_list.rst:683
msgid "Report syntax errors [syntax]"
msgstr ""

#: ../../source/error_code_list.rst:685
msgid ""
"If the code being checked is not syntactically valid, mypy issues a "
"syntax error. Most, but not all, syntax errors are *blocking errors*: "
"they can't be ignored with a ``# type: ignore`` comment."
msgstr ""

#: ../../source/error_code_list.rst:690
msgid "Miscellaneous checks [misc]"
msgstr ""

#: ../../source/error_code_list.rst:692
msgid ""
"Mypy performs numerous other, less commonly failing checks that don't "
"have specific error codes. These use the ``misc`` error code. Other than "
"being used for multiple unrelated errors, the ``misc`` error code is not "
"special. For example, you can ignore all errors in this category by using"
" ``# type: ignore[misc]`` comment. Since these errors are not expected to"
" be common, it's unlikely that you'll see two *different* errors with the"
" ``misc`` code on a single line -- though this can certainly happen once "
"in a while."
msgstr ""

#: ../../source/error_code_list.rst:703
msgid ""
"Future mypy versions will likely add new error codes for some errors that"
" currently use the ``misc`` error code."
msgstr ""

