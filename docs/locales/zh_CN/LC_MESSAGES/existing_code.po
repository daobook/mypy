# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2016, Jukka Lehtosalo
# This file is distributed under the same license as the Mypy package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Mypy "
"0.940+dev.ff5f71d674aece3095b7a623cc910e48c5a01c1e.dirty\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-03-04 14:39+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"

#: ../../source/existing_code.rst:4
msgid "Using mypy with an existing codebase"
msgstr ""

#: ../../source/existing_code.rst:6
msgid ""
"This section explains how to get started using mypy with an existing, "
"significant codebase that has little or no type annotations. If you are a"
" beginner, you can skip this section."
msgstr ""

#: ../../source/existing_code.rst:10
msgid "These steps will get you started with mypy on an existing codebase:"
msgstr ""

#: ../../source/existing_code.rst:12
msgid "Start small -- get a clean mypy build for some files, with few annotations"
msgstr ""

#: ../../source/existing_code.rst:15
msgid "Write a mypy runner script to ensure consistent results"
msgstr ""

#: ../../source/existing_code.rst:17
msgid "Run mypy in Continuous Integration to prevent type errors"
msgstr ""

#: ../../source/existing_code.rst:19
msgid "Gradually annotate commonly imported modules"
msgstr ""

#: ../../source/existing_code.rst:21
msgid "Write annotations as you modify existing code and write new code"
msgstr ""

#: ../../source/existing_code.rst:23
msgid ""
"Use :doc:`monkeytype:index` or `PyAnnotate`_ to automatically annotate "
"legacy code"
msgstr ""

#: ../../source/existing_code.rst:25
msgid ""
"We discuss all of these points in some detail below, and a few optional "
"follow-up steps."
msgstr ""

#: ../../source/existing_code.rst:29
msgid "Start small"
msgstr ""

#: ../../source/existing_code.rst:31
msgid ""
"If your codebase is large, pick a subset of your codebase (say, 5,000 to "
"50,000 lines) and run mypy only on this subset at first, *without any "
"annotations*. This shouldn't take more than a day or two to implement, so"
" you start enjoying benefits soon."
msgstr ""

#: ../../source/existing_code.rst:36
msgid ""
"You'll likely need to fix some mypy errors, either by inserting "
"annotations requested by mypy or by adding ``# type: ignore`` comments to"
" silence errors you don't want to fix now."
msgstr ""

#: ../../source/existing_code.rst:40
msgid ""
"In particular, mypy often generates errors about modules that it can't "
"find or that don't have stub files:"
msgstr ""

#: ../../source/existing_code.rst:49
msgid ""
"This is normal, and you can easily ignore these errors. For example, here"
" we ignore an error about a third-party module ``frobnicate`` that "
"doesn't have stubs using ``# type: ignore``:"
msgstr ""

#: ../../source/existing_code.rst:59
msgid ""
"You can also use a mypy configuration file, which is convenient if there "
"are a large number of errors to ignore. For example, to disable errors "
"about importing ``frobnicate`` and ``acme`` everywhere in your codebase, "
"use a config like this:"
msgstr ""

#: ../../source/existing_code.rst:72
msgid ""
"You can add multiple sections for different modules that should be "
"ignored."
msgstr ""

#: ../../source/existing_code.rst:75
msgid "If your config file is named ``mypy.ini``, this is how you run mypy:"
msgstr ""

#: ../../source/existing_code.rst:81
msgid ""
"If you get a large number of errors, you may want to ignore all errors "
"about missing imports.  This can easily cause problems later on and hide "
"real errors, and it's only recommended as a last resort. For more "
"details, look :ref:`here <follow-imports>`."
msgstr ""

#: ../../source/existing_code.rst:86
msgid ""
"Mypy follows imports by default. This can result in a few files passed on"
" the command line causing mypy to process a large number of imported "
"files, resulting in lots of errors you don't want to deal with at the "
"moment. There is a config file option to disable this behavior, but since"
" this can hide errors, it's not recommended for most users."
msgstr ""

#: ../../source/existing_code.rst:93
msgid "Mypy runner script"
msgstr ""

#: ../../source/existing_code.rst:95
msgid ""
"Introduce a mypy runner script that runs mypy, so that every developer "
"will use mypy consistently. Here are some things you may want to do in "
"the script:"
msgstr ""

#: ../../source/existing_code.rst:99
msgid "Ensure that the correct version of mypy is installed."
msgstr ""

#: ../../source/existing_code.rst:101
msgid "Specify mypy config file or command-line options."
msgstr ""

#: ../../source/existing_code.rst:103
msgid ""
"Provide set of files to type check. You may want to implement inclusion "
"and exclusion filters for full control of the file list."
msgstr ""

#: ../../source/existing_code.rst:108
msgid "Continuous Integration"
msgstr ""

#: ../../source/existing_code.rst:110
msgid ""
"Once you have a clean mypy run and a runner script for a part of your "
"codebase, set up your Continuous Integration (CI) system to run mypy to "
"ensure that developers won't introduce bad annotations. A simple CI "
"script could look something like this:"
msgstr ""

#: ../../source/existing_code.rst:121
msgid "Annotate widely imported modules"
msgstr ""

#: ../../source/existing_code.rst:123
msgid ""
"Most projects have some widely imported modules, such as utilities or "
"model classes. It's a good idea to annotate these pretty early on, since "
"this allows code using these modules to be type checked more effectively."
" Since mypy supports gradual typing, it's okay to leave some of these "
"modules unannotated. The more you annotate, the more useful mypy will be,"
" but even a little annotation coverage is useful."
msgstr ""

#: ../../source/existing_code.rst:131
msgid "Write annotations as you go"
msgstr ""

#: ../../source/existing_code.rst:133
msgid ""
"Now you are ready to include type annotations in your development "
"workflows. Consider adding something like these in your code style "
"conventions:"
msgstr ""

#: ../../source/existing_code.rst:137
msgid "Developers should add annotations for any new code."
msgstr ""

#: ../../source/existing_code.rst:138
msgid "It's also encouraged to write annotations when you modify existing code."
msgstr ""

#: ../../source/existing_code.rst:140
msgid ""
"This way you'll gradually increase annotation coverage in your codebase "
"without much effort."
msgstr ""

#: ../../source/existing_code.rst:144
msgid "Automate annotation of legacy code"
msgstr ""

#: ../../source/existing_code.rst:146
msgid ""
"There are tools for automatically adding draft annotations based on type "
"profiles collected at runtime.  Tools include :doc:`monkeytype:index` "
"(Python 3) and `PyAnnotate`_."
msgstr ""

#: ../../source/existing_code.rst:150
msgid ""
"A simple approach is to collect types from test runs. This may work well "
"if your test coverage is good (and if your tests aren't very slow)."
msgstr ""

#: ../../source/existing_code.rst:154
msgid ""
"Another approach is to enable type collection for a small, random "
"fraction of production network requests.  This clearly requires more "
"care, as type collection could impact the reliability or the performance "
"of your service."
msgstr ""

#: ../../source/existing_code.rst:160
msgid "Speed up mypy runs"
msgstr ""

#: ../../source/existing_code.rst:162
msgid ""
"You can use :ref:`mypy daemon <mypy_daemon>` to get much faster "
"incremental mypy runs. The larger your project is, the more useful this "
"will be.  If your project has at least 100,000 lines of code or so, you "
"may also want to set up :ref:`remote caching <remote-cache>` for further "
"speedups."
msgstr ""

#: ../../source/existing_code.rst:169
msgid "Introduce stricter options"
msgstr ""

#: ../../source/existing_code.rst:171
msgid ""
"Mypy is very configurable. Once you get started with static typing, you "
"may want to explore the various strictness options mypy provides to catch"
" more bugs. For example, you can ask mypy to require annotations for all "
"functions in certain modules to avoid accidentally introducing code that "
"won't be type checked using :confval:`disallow_untyped_defs`, or type "
"check code without annotations as well with "
":confval:`check_untyped_defs`. Refer to :ref:`config-file` for the "
"details."
msgstr ""

