# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2016, Jukka Lehtosalo
# This file is distributed under the same license as the Mypy package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Mypy "
"0.940+dev.ff5f71d674aece3095b7a623cc910e48c5a01c1e.dirty\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-03-04 14:39+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"

#: ../../source/runtime_troubles.rst:4
msgid "Annotation issues at runtime"
msgstr ""

#: ../../source/runtime_troubles.rst:6
msgid ""
"Idiomatic use of type annotations can sometimes run up against what a "
"given version of Python considers legal code. This section describes "
"these scenarios and explains how to get your code running again. "
"Generally speaking, we have three tools at our disposal:"
msgstr ""

#: ../../source/runtime_troubles.rst:11
msgid ""
"For Python 3.7 through 3.9, use of ``from __future__ import annotations``"
" (:pep:`563`), made the default in Python 3.11 and later"
msgstr ""

#: ../../source/runtime_troubles.rst:13
msgid "Use of string literal types or type comments"
msgstr ""

#: ../../source/runtime_troubles.rst:14
msgid "Use of ``typing.TYPE_CHECKING``"
msgstr ""

#: ../../source/runtime_troubles.rst:16
msgid ""
"We provide a description of these before moving onto discussion of "
"specific problems you may encounter."
msgstr ""

#: ../../source/runtime_troubles.rst:22
msgid "String literal types"
msgstr ""

#: ../../source/runtime_troubles.rst:24
msgid ""
"Type comments can't cause runtime errors because comments are not "
"evaluated by Python. In a similar way, using string literal types "
"sidesteps the problem of annotations that would cause runtime errors."
msgstr ""

#: ../../source/runtime_troubles.rst:28
msgid ""
"Any type can be entered as a string literal, and you can combine string-"
"literal types with non-string-literal types freely:"
msgstr ""

#: ../../source/runtime_troubles.rst:38
msgid ""
"String literal types are never needed in ``# type:`` comments and "
":ref:`stub files <stub-files>`."
msgstr ""

#: ../../source/runtime_troubles.rst:40
msgid ""
"String literal types must be defined (or imported) later *in the same "
"module*. They cannot be used to leave cross-module references unresolved."
"  (For dealing with import cycles, see :ref:`import-cycles`.)"
msgstr ""

#: ../../source/runtime_troubles.rst:47
msgid "Future annotations import (PEP 563)"
msgstr ""

#: ../../source/runtime_troubles.rst:49
msgid ""
"Many of the issues described here are caused by Python trying to evaluate"
" annotations. From Python 3.11 on, Python will no longer attempt to "
"evaluate function and variable annotations. This behaviour is made "
"available in Python 3.7 and later through the use of ``from __future__ "
"import annotations``."
msgstr ""

#: ../../source/runtime_troubles.rst:54
msgid ""
"This can be thought of as automatic string literal-ification of all "
"function and variable annotations. Note that function and variable "
"annotations are still required to be valid Python syntax. For more "
"details, see :pep:`563`."
msgstr ""

#: ../../source/runtime_troubles.rst:60
msgid ""
"Even with the ``__future__`` import, there are some scenarios that could "
"still require string literals or result in errors, typically involving "
"use of forward references or generics in:"
msgstr ""

#: ../../source/runtime_troubles.rst:64
msgid ":ref:`type aliases <type-aliases>`;"
msgstr ""

#: ../../source/runtime_troubles.rst:65
msgid ":ref:`type narrowing <type-narrowing>`;"
msgstr ""

#: ../../source/runtime_troubles.rst:66
msgid ""
"type definitions (see :py:class:`~typing.TypeVar`, "
":py:func:`~typing.NewType`, :py:class:`~typing.NamedTuple`);"
msgstr ""

#: ../../source/runtime_troubles.rst:67
msgid "base classes."
msgstr ""

#: ../../source/runtime_troubles.rst:79
msgid ""
"Some libraries may have use cases for dynamic evaluation of annotations, "
"for instance, through use of ``typing.get_type_hints`` or ``eval``. If "
"your annotation would raise an error when evaluated (say by using "
":pep:`604` syntax with Python 3.9), you may need to be careful when using"
" such libraries."
msgstr ""

#: ../../source/runtime_troubles.rst:88
msgid "typing.TYPE_CHECKING"
msgstr ""

#: ../../source/runtime_troubles.rst:90
msgid ""
"The :py:mod:`typing` module defines a :py:data:`~typing.TYPE_CHECKING` "
"constant that is ``False`` at runtime but treated as ``True`` while type "
"checking."
msgstr ""

#: ../../source/runtime_troubles.rst:93
msgid ""
"Since code inside ``if TYPE_CHECKING:`` is not executed at runtime, it "
"provides a convenient way to tell mypy something without the code being "
"evaluated at runtime. This is most useful for resolving :ref:`import "
"cycles <import-cycles>`."
msgstr ""

#: ../../source/runtime_troubles.rst:98
msgid "Class name forward references"
msgstr ""

#: ../../source/runtime_troubles.rst:100
msgid ""
"Python does not allow references to a class object before the class is "
"defined (aka forward reference). Thus this code does not work as "
"expected:"
msgstr ""

#: ../../source/runtime_troubles.rst:108
msgid ""
"Starting from Python 3.7, you can add ``from __future__ import "
"annotations`` to resolve this, as discussed earlier:"
msgstr ""

#: ../../source/runtime_troubles.rst:118
msgid ""
"For Python 3.6 and below, you can enter the type as a string literal or "
"type comment:"
msgstr ""

#: ../../source/runtime_troubles.rst:130
msgid ""
"Of course, instead of using future annotations import or string literal "
"types, you could move the function definition after the class definition."
" This is not always desirable or even possible, though."
msgstr ""

#: ../../source/runtime_troubles.rst:137
msgid "Import cycles"
msgstr ""

#: ../../source/runtime_troubles.rst:139
msgid ""
"An import cycle occurs where module A imports module B and module B "
"imports module A (perhaps indirectly, e.g. ``A -> B -> C -> A``). "
"Sometimes in order to add type annotations you have to add extra imports "
"to a module and those imports cause cycles that didn't exist before. This"
" can lead to errors at runtime like:"
msgstr ""

#: ../../source/runtime_troubles.rst:149
msgid ""
"If those cycles do become a problem when running your program, there's a "
"trick: if the import is only needed for type annotations and you're using"
" a) the :ref:`future annotations import<future-annotations>`, or b) "
"string literals or type comments for the relevant annotations, you can "
"write the imports inside ``if TYPE_CHECKING:`` so that they are not "
"executed at runtime. Example:"
msgstr ""

#: ../../source/runtime_troubles.rst:155
msgid "File ``foo.py``:"
msgstr ""

#: ../../source/runtime_troubles.rst:167
msgid "File ``bar.py``:"
msgstr ""

#: ../../source/runtime_troubles.rst:180
msgid "Using classes that are generic in stubs but not at runtime"
msgstr ""

#: ../../source/runtime_troubles.rst:182
msgid ""
"Some classes are declared as :ref:`generic<generic-classes>` in stubs, "
"but not at runtime."
msgstr ""

#: ../../source/runtime_troubles.rst:185
msgid ""
"In Python 3.8 and earlier, there are several examples within the standard"
" library, for instance, :py:class:`os.PathLike` and "
":py:class:`queue.Queue`. Subscripting such a class will result in a "
"runtime error:"
msgstr ""

#: ../../source/runtime_troubles.rst:198
msgid ""
"To avoid errors from use of these generics in annotations, just use the "
":ref:`future annotations import<future-annotations>` (or string literals "
"or type comments for Python 3.6 and below)."
msgstr ""

#: ../../source/runtime_troubles.rst:202
msgid ""
"To avoid errors when inheriting from these classes, things are a little "
"more complicated and you need to use :ref:`typing.TYPE_CHECKING <typing-"
"type-checking>`:"
msgstr ""

#: ../../source/runtime_troubles.rst:222
msgid "If your subclass is also generic, you can use the following:"
msgstr ""

#: ../../source/runtime_troubles.rst:240
msgid ""
"In Python 3.9, we can just inherit directly from ``Queue[str]`` or "
"``Queue[T]`` since its :py:class:`queue.Queue` implements "
":py:meth:`__class_getitem__`, so the class object can be subscripted at "
"runtime without issue."
msgstr ""

#: ../../source/runtime_troubles.rst:245
msgid "Using types defined in stubs but not at runtime"
msgstr ""

#: ../../source/runtime_troubles.rst:247
msgid ""
"Sometimes stubs that you're using may define types you wish to re-use "
"that do not exist at runtime. Importing these types naively will cause "
"your code to fail at runtime with ``ImportError`` or "
"``ModuleNotFoundError``. Similar to previous sections, these can be dealt"
" with by using :ref:`typing.TYPE_CHECKING <typing-type-checking>`:"
msgstr ""

#: ../../source/runtime_troubles.rst:262
msgid "Using generic builtins"
msgstr ""

#: ../../source/runtime_troubles.rst:264
msgid ""
"Starting with Python 3.9 (:pep:`585`), the type objects of many "
"collections in the standard library support subscription at runtime. This"
" means that you no longer have to import the equivalents from "
":py:mod:`typing`; you can simply use the built-in collections or those "
"from :py:mod:`collections.abc`:"
msgstr ""

#: ../../source/runtime_troubles.rst:276
msgid ""
"There is limited support for using this syntax in Python 3.7 and later as"
" well. If you use ``from __future__ import annotations``, mypy will "
"understand this syntax in annotations. However, since this will not be "
"supported by the Python interpreter at runtime, make sure you're aware of"
" the caveats mentioned in the notes at :ref:`future annotations import"
"<future-annotations>`."
msgstr ""

#: ../../source/runtime_troubles.rst:283
msgid "Using X | Y syntax for Unions"
msgstr ""

#: ../../source/runtime_troubles.rst:285
msgid ""
"Starting with Python 3.10 (:pep:`604`), you can spell union types as ``x:"
" int | str``, instead of ``x: typing.Union[int, str]``."
msgstr ""

#: ../../source/runtime_troubles.rst:288
msgid ""
"There is limited support for using this syntax in Python 3.7 and later as"
" well. If you use ``from __future__ import annotations``, mypy will "
"understand this syntax in annotations, string literal types, type "
"comments and stub files. However, since this will not be supported by the"
" Python interpreter at runtime (if evaluated, ``int | str`` will raise "
"``TypeError: unsupported operand type(s) for |: 'type' and 'type'``), "
"make sure you're aware of the caveats mentioned in the notes at "
":ref:`future annotations import<future-annotations>`."
msgstr ""

#: ../../source/runtime_troubles.rst:297
msgid "Using new additions to the typing module"
msgstr ""

#: ../../source/runtime_troubles.rst:299
msgid ""
"You may find yourself wanting to use features added to the "
":py:mod:`typing` module in earlier versions of Python than the addition, "
"for example, using any of ``Literal``, ``Protocol``, ``TypedDict`` with "
"Python 3.6."
msgstr ""

#: ../../source/runtime_troubles.rst:303
msgid ""
"The easiest way to do this is to install and use the "
"``typing_extensions`` package from PyPI for the relevant imports, for "
"example:"
msgstr ""

#: ../../source/runtime_troubles.rst:311
msgid ""
"If you don't want to rely on ``typing_extensions`` being installed on "
"newer Pythons, you could alternatively use:"
msgstr ""

#: ../../source/runtime_troubles.rst:324
msgid ""
"This plays nicely well with following :pep:`508` dependency "
"specification: ``typing_extensions; python_version<\"3.8\"``"
msgstr ""

