
<!DOCTYPE html>

<html lang="zh_CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>泛型 &#8212; Mypy 0.940+dev.7f0839b552c99f62636632bfd44522e91b26dc54 文档</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/classic.css" />
    
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/translations.js"></script>
    
    <link rel="index" title="索引" href="genindex.html" />
    <link rel="search" title="搜索" href="search.html" />
    <link rel="next" title="More types" href="more_types.html" />
    <link rel="prev" title="Stub files" href="stubs.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="总目录"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="more_types.html" title="More types"
             accesskey="N">下一页</a> |</li>
        <li class="right" >
          <a href="stubs.html" title="Stub files"
             accesskey="P">上一页</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Mypy 0.940+dev.7f0839b552c99f62636632bfd44522e91b26dc54 文档</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">泛型</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="generics">
<h1>泛型<a class="headerlink" href="#generics" title="永久链接至标题">¶</a></h1>
<p>本节解释了如何定义自己的泛型类，这些类接受一个或多个类型参数，类似于 <code class="docutils literal notranslate"><span class="pre">list[X]</span></code> 等内置类型。用户定义的泛型是一种中等高级的特性，你可以在不使用它们的情况下走得很远——可以跳过这一节，稍后再回来。</p>
<section id="defining-generic-classes">
<span id="generic-classes"></span><h2>定义泛型类<a class="headerlink" href="#defining-generic-classes" title="永久链接至标题">¶</a></h2>
<p>内置 collection 类是泛型类。泛型类型有一个或多个类型参数，这些参数可以是任意类型。例如，<code class="docutils literal notranslate"><span class="pre">dict[int,</span> <span class="pre">str]</span></code> 有类型参数 <code class="docutils literal notranslate"><span class="pre">int</span></code> 和 <code class="docutils literal notranslate"><span class="pre">str</span></code>，而 <code class="docutils literal notranslate"><span class="pre">list[int]</span></code> 有类型参数 <code class="docutils literal notranslate"><span class="pre">int</span></code>。</p>
<p>程序也可以定义新的泛型类。下面是一个非常简单的泛型类，它代表一个堆栈：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">TypeVar</span><span class="p">,</span> <span class="n">Generic</span>

<span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Stack</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="n">T</span><span class="p">]):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Create an empty list with items of type T</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">T</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">push</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">empty</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Stack</span></code> 类可以用来表示任何类型的堆栈：<code class="docutils literal notranslate"><span class="pre">Stack[int]</span></code>，<code class="docutils literal notranslate"><span class="pre">Stack[tuple[int,</span> <span class="pre">str]]</span></code> 等等。</p>
<p>使用 <code class="docutils literal notranslate"><span class="pre">Stack</span></code> 类似于内置容器类型：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Construct an empty Stack[int] instance</span>
<span class="n">stack</span> <span class="o">=</span> <span class="n">Stack</span><span class="p">[</span><span class="nb">int</span><span class="p">]()</span>
<span class="n">stack</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
<span class="n">stack</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>        <span class="c1"># Type error</span>
</pre></div>
</div>
<p>类型推理也适用于用户定义的泛型类型：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="n">stack</span><span class="p">:</span> <span class="n">Stack</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span> <span class="o">...</span>

<span class="n">process</span><span class="p">(</span><span class="n">Stack</span><span class="p">())</span>   <span class="c1"># Argument has inferred type Stack[int]</span>
</pre></div>
</div>
<p>泛型类型实例的构造也要进行类型检查：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Box</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="n">T</span><span class="p">]):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">content</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">content</span> <span class="o">=</span> <span class="n">content</span>

<span class="n">Box</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># OK, inferred type is Box[int]</span>
<span class="n">Box</span><span class="p">[</span><span class="nb">int</span><span class="p">](</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># Also OK</span>
<span class="n">s</span> <span class="o">=</span> <span class="s1">&#39;some string&#39;</span>
<span class="n">Box</span><span class="p">[</span><span class="nb">int</span><span class="p">](</span><span class="n">s</span><span class="p">)</span>  <span class="c1"># Type error</span>
</pre></div>
</div>
</section>
<section id="generic-class-internals">
<h2>泛型类内部<a class="headerlink" href="#generic-class-internals" title="永久链接至标题">¶</a></h2>
<p>你可能想知道当你在运行时索引 <code class="docutils literal notranslate"><span class="pre">Stack</span></code> 时会发生什么。索引 <code class="docutils literal notranslate"><span class="pre">Stack</span></code> 返回一个 <em>泛型别名</em> 到 <code class="docutils literal notranslate"><span class="pre">Stack</span></code>，在实例化时返回原始类的实例：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">Stack</span><span class="p">)</span>
<span class="go">__main__.Stack</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">Stack</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span>
<span class="go">__main__.Stack[int]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">Stack</span><span class="p">[</span><span class="nb">int</span><span class="p">]()</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span>
<span class="go">__main__.Stack</span>
</pre></div>
</div>
<p>泛型别名可以实例化或子类化，类似于真实的类，但上面的例子说明类型变量在运行时被删除。泛型 <code class="docutils literal notranslate"><span class="pre">Stack</span></code> 实例只是普通的 Python 对象，由于泛型，它们没有额外的运行时开销或魔术，除了一个重载索引操作符的元类。</p>
<p>请注意，在 Python 3.8 及以下版本中，内置类型 <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(在 Python v3.10)"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a>，<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(在 Python v3.10)"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a> 和其他类型不支持索引。这就是我们在 <a class="reference external" href="https://docs.python.org/3/library/typing.html#module-typing" title="(在 Python v3.10)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">typing</span></code></a> 模块中使用别名 <a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.List" title="(在 Python v3.10)"><code class="xref py py-class docutils literal notranslate"><span class="pre">List</span></code></a>，<a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Dict" title="(在 Python v3.10)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Dict</span></code></a> 等的原因。：索引这些别名会给你一个泛型别名，它类似于在 Python 的最新版本中直接索引目标类所构造的泛型别名：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Only relevant for Python 3.8 and below</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># For Python 3.9 onwards, prefer `list[int]` syntax</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span>
<span class="go">typing.List[int]</span>
</pre></div>
</div>
<p>请注意，<code class="docutils literal notranslate"><span class="pre">typing</span></code> 中的泛型别名不支持构造实例：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">Type List cannot be instantiated; use list() instead</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>在 Python 3.6 中，对泛型类型或类型别名进行索引将产生实际的类型对象。这意味着类型注释中的泛型类型可能有很大的运行时成本。这在 Python 3.7 中被改变了，索引泛型类型变成了一个廉价的操作。</p>
</div>
</section>
<section id="defining-sub-classes-of-generic-classes">
<span id="generic-subclasses"></span><h2>定义泛型类的子类<a class="headerlink" href="#defining-sub-classes-of-generic-classes" title="永久链接至标题">¶</a></h2>
<p>用户定义的泛型类和定义在 <a class="reference external" href="https://docs.python.org/3/library/typing.html#module-typing" title="(在 Python v3.10)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">typing</span></code></a> 中的泛型类可以用作其他类的基类，包括泛型类和非泛型类。例如：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Generic</span><span class="p">,</span> <span class="n">TypeVar</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">,</span> <span class="n">Iterator</span>

<span class="n">KT</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;KT&#39;</span><span class="p">)</span>
<span class="n">VT</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;VT&#39;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">MyMap</span><span class="p">(</span><span class="n">Mapping</span><span class="p">[</span><span class="n">KT</span><span class="p">,</span> <span class="n">VT</span><span class="p">]):</span>  <span class="c1"># This is a generic subclass of Mapping</span>
    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="n">KT</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">VT</span><span class="p">:</span>
        <span class="o">...</span>  <span class="c1"># Implementations omitted</span>
    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="n">KT</span><span class="p">]:</span>
        <span class="o">...</span>
    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="o">...</span>

<span class="n">items</span><span class="p">:</span> <span class="n">MyMap</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>  <span class="c1"># Okay</span>

<span class="k">class</span> <span class="nc">StrDict</span><span class="p">(</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]):</span>  <span class="c1"># This is a non-generic subclass of dict</span>
    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="s1">&#39;StrDict(</span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__str__</span><span class="p">())</span>

<span class="n">data</span><span class="p">:</span> <span class="n">StrDict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>  <span class="c1"># Error! StrDict is not generic</span>
<span class="n">data2</span><span class="p">:</span> <span class="n">StrDict</span>  <span class="c1"># OK</span>

<span class="k">class</span> <span class="nc">Receiver</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="n">T</span><span class="p">]):</span>
    <span class="k">def</span> <span class="nf">accept</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="o">...</span>

<span class="k">class</span> <span class="nc">AdvancedReceiver</span><span class="p">(</span><span class="n">Receiver</span><span class="p">[</span><span class="n">T</span><span class="p">]):</span>
    <span class="o">...</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>你必须添加显式的 <a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Mapping" title="(在 Python v3.10)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Mapping</span></code></a> 基类，如果你想让 mypy 把用户定义的类看作映射（和 <a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Sequence" title="(在 Python v3.10)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Sequence</span></code></a> 表示序列，等等）。这是因为 mypy 不像 <a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Iterable" title="(在 Python v3.10)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Iterable</span></code></a> 使用 <a class="reference internal" href="protocols.html#protocol-types"><span class="std std-ref">structural subtyping</span></a> 这样的简单协议那样，对这些 ABC 使用 <em>结构性子类型</em>。</p>
</div>
<p><a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Generic" title="(在 Python v3.10)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generic</span></code></a> 可以在基类中省略，如果有其他基类包含类型变量，例如上面例子中的 <code class="docutils literal notranslate"><span class="pre">Mapping[KT,</span> <span class="pre">VT]</span></code>。如果你使用了 <code class="docutils literal notranslate"><span class="pre">Generic[...]</span></code>，然后它应该列出所有类型变量出现在其他基（或更多，如果需要）。类型变量的顺序由以下规则定义：</p>
<ul class="simple">
<li><p>如果 <code class="docutils literal notranslate"><span class="pre">Generic[...]</span></code> 存在，那么变量的顺序总是由它们在 <code class="docutils literal notranslate"><span class="pre">Generic[...]</span></code> 中的顺序决定的。</p></li>
<li><p>如果没有 <code class="docutils literal notranslate"><span class="pre">Generic[...]</span></code>，然后按字典顺序（即按首次出现）收集所有类型变量。</p></li>
</ul>
<p>示例：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Generic</span><span class="p">,</span> <span class="n">TypeVar</span><span class="p">,</span> <span class="n">Any</span>

<span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
<span class="n">S</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;S&#39;</span><span class="p">)</span>
<span class="n">U</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;U&#39;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">One</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="n">T</span><span class="p">]):</span> <span class="o">...</span>
<span class="k">class</span> <span class="nc">Another</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="n">T</span><span class="p">]):</span> <span class="o">...</span>

<span class="k">class</span> <span class="nc">First</span><span class="p">(</span><span class="n">One</span><span class="p">[</span><span class="n">T</span><span class="p">],</span> <span class="n">Another</span><span class="p">[</span><span class="n">S</span><span class="p">]):</span> <span class="o">...</span>
<span class="k">class</span> <span class="nc">Second</span><span class="p">(</span><span class="n">One</span><span class="p">[</span><span class="n">T</span><span class="p">],</span> <span class="n">Another</span><span class="p">[</span><span class="n">S</span><span class="p">],</span> <span class="n">Generic</span><span class="p">[</span><span class="n">S</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span> <span class="n">T</span><span class="p">]):</span> <span class="o">...</span>

<span class="n">x</span><span class="p">:</span> <span class="n">First</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span>        <span class="c1"># Here T is bound to int, S is bound to str</span>
<span class="n">y</span><span class="p">:</span> <span class="n">Second</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span>  <span class="c1"># Here T is Any, S is int, and U is str</span>
</pre></div>
</div>
</section>
<section id="generic-functions">
<span id="id1"></span><h2>泛型函数<a class="headerlink" href="#generic-functions" title="永久链接至标题">¶</a></h2>
<p>泛型类型变量也可以用来定义泛型函数：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">TypeVar</span><span class="p">,</span> <span class="n">Sequence</span>

<span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>      <span class="c1"># Declare type variable</span>

<span class="k">def</span> <span class="nf">first</span><span class="p">(</span><span class="n">seq</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">T</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="p">:</span>   <span class="c1"># Generic function</span>
    <span class="k">return</span> <span class="n">seq</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<p>“与泛型类一样，类型变量可以用任何类型替换。这意味着 <code class="docutils literal notranslate"><span class="pre">first</span></code> 可以用于任何序列类型，并且返回类型派生自序列项类型。例如：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Assume first defined as above.</span>

<span class="n">s</span> <span class="o">=</span> <span class="n">first</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">)</span>      <span class="c1"># s has type str.</span>
<span class="n">n</span> <span class="o">=</span> <span class="n">first</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>  <span class="c1"># n has type int.</span>
</pre></div>
</div>
<p>还要注意，类型变量的单个定义（如上面的 <code class="docutils literal notranslate"><span class="pre">T</span></code>）可以在多个泛型函数或类中使用。在这个例子中，我们在两个泛型函数中使用了相同的类型变量：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">TypeVar</span><span class="p">,</span> <span class="n">Sequence</span>

<span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>      <span class="c1"># Declare type variable</span>

<span class="k">def</span> <span class="nf">first</span><span class="p">(</span><span class="n">seq</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">T</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">seq</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">last</span><span class="p">(</span><span class="n">seq</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">T</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">seq</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<p>变量不能在其类型中具有类型变量，除非该类型变量被绑定在包含的泛型类或函数中。</p>
</section>
<section id="generic-methods-and-generic-self">
<span id="id2"></span><h2>泛型方法和泛型 self<a class="headerlink" href="#generic-methods-and-generic-self" title="永久链接至标题">¶</a></h2>
<p>你也可以定义泛型方法——只是在方法签名中使用不同于 class type 变量的 type 变量。特别地，<code class="docutils literal notranslate"><span class="pre">self</span></code> 也可能是泛型的，它允许方法在访问点返回最精确的类型。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>这个功能是实验性的。使用类型注解检查 self 参数的代码仍然没有完全实现。Mypy 可能禁止有效的代码，也可能允许不安全的代码。</p>
</div>
<p>例如，通过这种方式，您可以检查 setter 方法的类型链：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">TypeVar</span>

<span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="s1">&#39;Shape&#39;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Shape</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">set_scale</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span> <span class="n">scale</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="o">=</span> <span class="n">scale</span>
        <span class="k">return</span> <span class="bp">self</span>

<span class="k">class</span> <span class="nc">Circle</span><span class="p">(</span><span class="n">Shape</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">set_radius</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Circle&#39;</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">radius</span> <span class="o">=</span> <span class="n">r</span>
        <span class="k">return</span> <span class="bp">self</span>

<span class="k">class</span> <span class="nc">Square</span><span class="p">(</span><span class="n">Shape</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">set_width</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">w</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Square&#39;</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">width</span> <span class="o">=</span> <span class="n">w</span>
        <span class="k">return</span> <span class="bp">self</span>

<span class="n">circle</span> <span class="o">=</span> <span class="n">Circle</span><span class="p">()</span><span class="o">.</span><span class="n">set_scale</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span><span class="o">.</span><span class="n">set_radius</span><span class="p">(</span><span class="mf">2.7</span><span class="p">)</span>  <span class="c1"># type: Circle</span>
<span class="n">square</span> <span class="o">=</span> <span class="n">Square</span><span class="p">()</span><span class="o">.</span><span class="n">set_scale</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span><span class="o">.</span><span class="n">set_width</span><span class="p">(</span><span class="mf">3.2</span><span class="p">)</span>  <span class="c1"># type: Square</span>
</pre></div>
</div>
<p>如果不使用泛型的 <code class="docutils literal notranslate"><span class="pre">self</span></code>，最后两行就不能正确地进行类型检查。</p>
<p>其他用途是工厂方法，如复制和反序列化。对于类方法，你也可以定义泛型的 <code class="docutils literal notranslate"><span class="pre">cls</span></code>，使用 <a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Type" title="(在 Python v3.10)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Type[T]</span></code></a>：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">TypeVar</span><span class="p">,</span> <span class="n">Type</span>

<span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="s1">&#39;Friend&#39;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Friend</span><span class="p">:</span>
    <span class="n">other</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># type: Friend</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">make_pair</span><span class="p">(</span><span class="bp">cls</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">T</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="n">T</span><span class="p">]:</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(),</span> <span class="bp">cls</span><span class="p">()</span>
        <span class="n">a</span><span class="o">.</span><span class="n">other</span> <span class="o">=</span> <span class="n">b</span>
        <span class="n">b</span><span class="o">.</span><span class="n">other</span> <span class="o">=</span> <span class="n">a</span>
        <span class="k">return</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span>

<span class="k">class</span> <span class="nc">SuperFriend</span><span class="p">(</span><span class="n">Friend</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">SuperFriend</span><span class="o">.</span><span class="n">make_pair</span><span class="p">()</span>
</pre></div>
</div>
<p>请注意，当用泛型 <code class="docutils literal notranslate"><span class="pre">self</span></code> 覆盖一个方法时，你必须也返回一个泛型 <code class="docutils literal notranslate"><span class="pre">self</span></code>，或者返回当前类的一个实例。在后一种情况下，你必须在以后所有的子类中实现这个方法。</p>
<p>还要注意，mypy 不能总是验证副本或反序列化方法的实现是否返回 self 的实际类型。因此，你可能需要在这些方法内部（但不是在调用站点）关闭 mypy，可能是通过使用 <code class="docutils literal notranslate"><span class="pre">Any</span></code> 类型。</p>
<p>关于 self-type 的一些高级用法，请参阅 <a class="reference internal" href="more_types.html#advanced-self"><span class="std std-ref">additional examples</span></a>。</p>
</section>
<section id="variance-of-generic-types">
<span id="variance-of-generics"></span><h2>泛型类型的方差<a class="headerlink" href="#variance-of-generic-types" title="永久链接至标题">¶</a></h2>
<p>根据它们之间的子类型关系，有三种主要的泛型类型：invariant、covariant 和 contravariant。假设有一对类型 <code class="docutils literal notranslate"><span class="pre">A</span></code> 和 <code class="docutils literal notranslate"><span class="pre">B</span></code>，而 <code class="docutils literal notranslate"><span class="pre">B</span></code> 是 <code class="docutils literal notranslate"><span class="pre">A</span></code> 的子类型，它们的定义如下：</p>
<ul class="simple">
<li><p>如果 <code class="docutils literal notranslate"><span class="pre">MyCovGen[B,</span> <span class="pre">...]</span></code> 总是 <code class="docutils literal notranslate"><span class="pre">MyCovGen[A,</span> <span class="pre">...]</span></code> 的子类型，则泛型类 <code class="docutils literal notranslate"><span class="pre">MyCovGen[T,</span> <span class="pre">...]</span></code> 被称为类型变量 <code class="docutils literal notranslate"><span class="pre">T</span></code> 的 <strong>协变量</strong> （covariant）。</p></li>
<li><p>如果 <code class="docutils literal notranslate"><span class="pre">MyContraGen[A,</span> <span class="pre">...]</span></code> 总是 <code class="docutils literal notranslate"><span class="pre">MyContraGen[B,</span> <span class="pre">...]</span></code> 的子类型，则称泛型类 <code class="docutils literal notranslate"><span class="pre">MyContraGen[T,</span> <span class="pre">...]</span></code> 为类型变量 <code class="docutils literal notranslate"><span class="pre">T</span></code> 的 <strong>逆变量</strong> （contravariant）。</p></li>
<li><p>如果以上两个都不成立，则称泛型类 <code class="docutils literal notranslate"><span class="pre">MyInvGen[T,</span> <span class="pre">...]</span></code> 为类型变量 <code class="docutils literal notranslate"><span class="pre">T</span></code> 的 <strong>不变量</strong> （invariant）。</p></li>
</ul>
<p>让我们举几个简单的例子来说明这一点：</p>
<ul>
<li><p><a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Union" title="(在 Python v3.10)"><code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code></a> 在所有变量中都是协变的：<code class="docutils literal notranslate"><span class="pre">Union[Cat,</span> <span class="pre">int]</span></code> 是 <code class="docutils literal notranslate"><span class="pre">Union[Animal,</span> <span class="pre">int]</span></code> 的子类型，<code class="docutils literal notranslate"><span class="pre">Union[Dog,</span> <span class="pre">int]</span></code> 也是 <code class="docutils literal notranslate"><span class="pre">Union[Animal,</span> <span class="pre">int]</span></code> 的子类型。大多数不可变容器，比如 <a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Sequence" title="(在 Python v3.10)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Sequence</span></code></a> 和 <a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.FrozenSet" title="(在 Python v3.10)"><code class="xref py py-class docutils literal notranslate"><span class="pre">FrozenSet</span></code></a> 也是协变的。</p></li>
<li><p><a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Callable" title="(在 Python v3.10)"><code class="xref py py-data docutils literal notranslate"><span class="pre">Callable</span></code></a> 是在参数类型中表现为逆变量类型的例子，即 <code class="docutils literal notranslate"><span class="pre">Callable[[Employee],</span> <span class="pre">int]</span></code> 是 <code class="docutils literal notranslate"><span class="pre">Callable[[Manager],</span> <span class="pre">int]</span></code> 的子类型。要理解这一点，请考虑一个函数：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">salaries</span><span class="p">(</span><span class="n">staff</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Manager</span><span class="p">],</span>
             <span class="n">accountant</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Manager</span><span class="p">],</span> <span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span> <span class="o">...</span>
</pre></div>
</div>
<p>这个函数需要可调用对象来计算 manager 的工资，如果给它一个可调用对象来计算任意 employee 的工资，它仍然是安全的。</p>
</li>
<li><p><a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.List" title="(在 Python v3.10)"><code class="xref py py-class docutils literal notranslate"><span class="pre">List</span></code></a> 是不变量泛型类型。天真地，人们会认为它是协变的，但是让我们考虑一下这个代码：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Shape</span><span class="p">:</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">Circle</span><span class="p">(</span><span class="n">Shape</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">rotate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="o">...</span>

<span class="k">def</span> <span class="nf">add_one</span><span class="p">(</span><span class="n">things</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Shape</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">things</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Shape</span><span class="p">())</span>

<span class="n">my_things</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Circle</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">add_one</span><span class="p">(</span><span class="n">my_things</span><span class="p">)</span>     <span class="c1"># This may appear safe, but...</span>
<span class="n">my_things</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">rotate</span><span class="p">()</span>  <span class="c1"># ...this will fail</span>
</pre></div>
</div>
<p>另一个不变类型的例子是 <a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Dict" title="(在 Python v3.10)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Dict</span></code></a>。大多数可变容器都是不变量。</p>
</li>
</ul>
<p>默认情况下，mypy 假定所有用户定义的泛型都是不变的。要将给定的泛型类声明为协变或逆变，请使用用特殊关键字参数 <code class="docutils literal notranslate"><span class="pre">covariant</span></code> 或 <code class="docutils literal notranslate"><span class="pre">contravariant</span></code> 定义的类型变量。例如：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Generic</span><span class="p">,</span> <span class="n">TypeVar</span>

<span class="n">T_co</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T_co&#39;</span><span class="p">,</span> <span class="n">covariant</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Box</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="n">T_co</span><span class="p">]):</span>  <span class="c1"># this type is declared covariant</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">content</span><span class="p">:</span> <span class="n">T_co</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_content</span> <span class="o">=</span> <span class="n">content</span>

    <span class="k">def</span> <span class="nf">get_content</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">T_co</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_content</span>

<span class="k">def</span> <span class="nf">look_into</span><span class="p">(</span><span class="n">box</span><span class="p">:</span> <span class="n">Box</span><span class="p">[</span><span class="n">Animal</span><span class="p">]):</span> <span class="o">...</span>

<span class="n">my_box</span> <span class="o">=</span> <span class="n">Box</span><span class="p">(</span><span class="n">Cat</span><span class="p">())</span>
<span class="n">look_into</span><span class="p">(</span><span class="n">my_box</span><span class="p">)</span>  <span class="c1"># OK, but mypy would complain here for an invariant type</span>
</pre></div>
</div>
</section>
<section id="type-variables-with-value-restriction">
<span id="type-variable-value-restriction"></span><h2>具有值限制的类型变量<a class="headerlink" href="#type-variables-with-value-restriction" title="永久链接至标题">¶</a></h2>
<p>默认情况下，类型变量可以被替换为任何类型。但是，有时候，拥有一个只能以某些特定类型作为值的类型变量是很有用的。典型的例子是类型变量只能有值 <code class="docutils literal notranslate"><span class="pre">str</span></code> 和 <code class="docutils literal notranslate"><span class="pre">bytes</span></code>：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">TypeVar</span>

<span class="n">AnyStr</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;AnyStr&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">)</span>
</pre></div>
</div>
<p>这实际上是非常常见的在 <a class="reference external" href="https://docs.python.org/3/library/typing.html#module-typing" title="(在 Python v3.10)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">typing</span></code></a> 中定义的类型变量 <a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.AnyStr" title="(在 Python v3.10)"><code class="xref py py-data docutils literal notranslate"><span class="pre">AnyStr</span></code></a>，我们不需要自己定义它。</p>
<p>We can use <a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.AnyStr" title="(在 Python v3.10)"><code class="xref py py-data docutils literal notranslate"><span class="pre">AnyStr</span></code></a> to define a function that can concatenate
two strings or bytes objects, but it can’t be called with other
argument types:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">AnyStr</span>

<span class="k">def</span> <span class="nf">concat</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">AnyStr</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">AnyStr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AnyStr</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>

<span class="n">concat</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">)</span>    <span class="c1"># Okay</span>
<span class="n">concat</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="sa">b</span><span class="s1">&#39;b&#39;</span><span class="p">)</span>  <span class="c1"># Okay</span>
<span class="n">concat</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>        <span class="c1"># Error!</span>
</pre></div>
</div>
<p>Note that this is different from a union type, since combinations
of <code class="docutils literal notranslate"><span class="pre">str</span></code> and <code class="docutils literal notranslate"><span class="pre">bytes</span></code> are not accepted:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">concat</span><span class="p">(</span><span class="s1">&#39;string&#39;</span><span class="p">,</span> <span class="sa">b</span><span class="s1">&#39;bytes&#39;</span><span class="p">)</span>   <span class="c1"># Error!</span>
</pre></div>
</div>
<p>In this case, this is exactly what we want, since it’s not possible
to concatenate a string and a bytes object! The type checker
will reject this function:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">union_concat</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">],</span> <span class="n">y</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">]:</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>  <span class="c1"># Error: can&#39;t concatenate str and bytes</span>
</pre></div>
</div>
<p>Another interesting special case is calling <code class="docutils literal notranslate"><span class="pre">concat()</span></code> with a
subtype of <code class="docutils literal notranslate"><span class="pre">str</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">S</span><span class="p">(</span><span class="nb">str</span><span class="p">):</span> <span class="k">pass</span>

<span class="n">ss</span> <span class="o">=</span> <span class="n">concat</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">),</span> <span class="n">S</span><span class="p">(</span><span class="s1">&#39;bar&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>You may expect that the type of <code class="docutils literal notranslate"><span class="pre">ss</span></code> is <code class="docutils literal notranslate"><span class="pre">S</span></code>, but the type is
actually <code class="docutils literal notranslate"><span class="pre">str</span></code>: a subtype gets promoted to one of the valid values
for the type variable, which in this case is <code class="docutils literal notranslate"><span class="pre">str</span></code>. This is thus
subtly different from <em>bounded quantification</em> in languages such as
Java, where the return type would be <code class="docutils literal notranslate"><span class="pre">S</span></code>. The way mypy implements
this is correct for <code class="docutils literal notranslate"><span class="pre">concat</span></code>, since <code class="docutils literal notranslate"><span class="pre">concat</span></code> actually returns a
<code class="docutils literal notranslate"><span class="pre">str</span></code> instance in the above example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">ss</span><span class="p">))</span>
<span class="go">&lt;class &#39;str&#39;&gt;</span>
</pre></div>
</div>
<p>You can also use a <a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.TypeVar" title="(在 Python v3.10)"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeVar</span></code></a> with a restricted set of possible
values when defining a generic class. For example, mypy uses the type
<a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Pattern" title="(在 Python v3.10)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pattern[AnyStr]</span></code></a> for the return value of <a class="reference external" href="https://docs.python.org/3/library/re.html#re.compile" title="(在 Python v3.10)"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.compile()</span></code></a>,
since regular expressions can be based on a string or a bytes pattern.</p>
</section>
<section id="type-variables-with-upper-bounds">
<span id="type-variable-upper-bound"></span><h2>具有上界的类型变量<a class="headerlink" href="#type-variables-with-upper-bounds" title="永久链接至标题">¶</a></h2>
<p>类型变量还可以被限制为具有特定类型的子类型的值。这个类型被称为类型变量的上限，用于 <a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.TypeVar" title="(在 Python v3.10)"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeVar</span></code></a> 的关键字参数 <code class="docutils literal notranslate"><span class="pre">bound=...</span></code>。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">TypeVar</span><span class="p">,</span> <span class="n">SupportsAbs</span>

<span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="n">SupportsAbs</span><span class="p">[</span><span class="nb">float</span><span class="p">])</span>
</pre></div>
</div>
<p>在使用类型变量 <code class="docutils literal notranslate"><span class="pre">T</span></code> 的泛型函数的定义中，<code class="docutils literal notranslate"><span class="pre">T</span></code> 表示的类型被假定为其上界的一个子类型，因此函数可以对 <code class="docutils literal notranslate"><span class="pre">T</span></code> 类型的值使用上界的方法。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">largest_in_absolute_value</span><span class="p">(</span><span class="o">*</span><span class="n">xs</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="p">:</span>
    <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="nb">abs</span><span class="p">)</span>  <span class="c1"># Okay, because T is a subtype of SupportsAbs[float].</span>
</pre></div>
</div>
<p>在调用这样一个函数时，类型 <code class="docutils literal notranslate"><span class="pre">T</span></code> 必须替换为其上界的子类型。继续上面的例子，</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">largest_in_absolute_value</span><span class="p">(</span><span class="o">-</span><span class="mf">3.5</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>   <span class="c1"># Okay, has type float.</span>
<span class="n">largest_in_absolute_value</span><span class="p">(</span><span class="mi">5</span><span class="o">+</span><span class="mi">6</span><span class="n">j</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>   <span class="c1"># Okay, has type complex.</span>
<span class="n">largest_in_absolute_value</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">)</span>  <span class="c1"># Error: &#39;str&#39; is not a subtype of SupportsAbs[float].</span>
</pre></div>
</div>
<p>泛型类的类型参数也可以有上限，以同样的方式限制类型参数的有效值。</p>
<p>类型变量不能同时具有值限制（参见 <a class="reference internal" href="#type-variable-value-restriction"><span class="std std-ref">具有值限制的类型变量</span></a>）和上限。</p>
</section>
<section id="declaring-decorators">
<span id="id3"></span><h2>声明装饰器<a class="headerlink" href="#declaring-decorators" title="永久链接至标题">¶</a></h2>
<p>类型变量上界的常见应用是声明装饰器，该装饰器保留它所装饰的函数的签名，而不管该签名是什么。</p>
<p>请注意，在 mypy 中，类装饰器的处理方式与函数装饰器不同：装饰类不会删除其类型，即使装饰器有不完整的类型注解。</p>
<p>下面是函数装饰器的完整示例：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">TypeVar</span><span class="p">,</span> <span class="n">cast</span>

<span class="n">F</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;F&#39;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">Any</span><span class="p">])</span>

<span class="c1"># A decorator that preserves the signature.</span>
<span class="k">def</span> <span class="nf">my_decorator</span><span class="p">(</span><span class="n">func</span><span class="p">:</span> <span class="n">F</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">F</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Calling&quot;</span><span class="p">,</span> <span class="n">func</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">cast</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">wrapper</span><span class="p">)</span>

<span class="c1"># A decorated function.</span>
<span class="nd">@my_decorator</span>
<span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

<span class="n">a</span> <span class="o">=</span> <span class="n">foo</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>
<span class="n">reveal_type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>  <span class="c1"># str</span>
<span class="n">foo</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>    <span class="c1"># Type check error: incompatible type &quot;str&quot;; expected &quot;int&quot;</span>
</pre></div>
</div>
<p>从最后一个块中，看到装饰函数 <code class="docutils literal notranslate"><span class="pre">foo()</span></code> 和 <code class="docutils literal notranslate"><span class="pre">bar()</span></code> 的签名与原始函数（在应用装饰器之前）的签名相同。</p>
<p><code class="docutils literal notranslate"><span class="pre">F</span></code> 的边界是用来在非函数（例如 <code class="docutils literal notranslate"><span class="pre">my_decorator(1)</span></code>）将被拒绝。</p>
<p>还要注意，<code class="docutils literal notranslate"><span class="pre">wrapper()</span></code> 函数不是类型检查的。包装器函数通常足够小，所以这不是一个大问题。这也是 <a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.cast" title="(在 Python v3.10)"><code class="xref py py-func docutils literal notranslate"><span class="pre">cast()</span></code></a> 调用 <code class="docutils literal notranslate"><span class="pre">my_decorator()</span></code> 中的 <code class="docutils literal notranslate"><span class="pre">return</span></code> 语句的原因。参阅 <a class="reference internal" href="type_narrowing.html#casts"><span class="std std-ref">casts</span></a>。</p>
<section id="decorator-factories">
<span id="id4"></span><h3>装饰器工厂<a class="headerlink" href="#decorator-factories" title="永久链接至标题">¶</a></h3>
<p>接受参数并返回装饰器（也称为二阶装饰器）的函数，类似地通过泛型得到支持：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">TypeVar</span>

<span class="n">F</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;F&#39;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">Any</span><span class="p">])</span>

<span class="k">def</span> <span class="nf">route</span><span class="p">(</span><span class="n">url</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">F</span><span class="p">],</span> <span class="n">F</span><span class="p">]:</span>
    <span class="o">...</span>

<span class="nd">@route</span><span class="p">(</span><span class="n">url</span><span class="o">=</span><span class="s1">&#39;/&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">index</span><span class="p">(</span><span class="n">request</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="k">return</span> <span class="s1">&#39;Hello world&#39;</span>
</pre></div>
</div>
<p>有时同个 decorator 既支持裸调用，也支持带参数的调用。这可以通过结合 <a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.overload" title="(在 Python v3.10)"><code class="xref py py-func docutils literal notranslate"><span class="pre">&#64;overload</span></code></a> 来实现：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">TypeVar</span><span class="p">,</span> <span class="n">overload</span>

<span class="n">F</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;F&#39;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">Any</span><span class="p">])</span>

<span class="c1"># Bare decorator usage</span>
<span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">atomic</span><span class="p">(</span><span class="n">__func</span><span class="p">:</span> <span class="n">F</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">F</span><span class="p">:</span> <span class="o">...</span>
<span class="c1"># Decorator with arguments</span>
<span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">atomic</span><span class="p">(</span><span class="o">*</span><span class="p">,</span> <span class="n">savepoint</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">F</span><span class="p">],</span> <span class="n">F</span><span class="p">]:</span> <span class="o">...</span>

<span class="c1"># Implementation</span>
<span class="k">def</span> <span class="nf">atomic</span><span class="p">(</span><span class="n">__func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">savepoint</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">decorator</span><span class="p">(</span><span class="n">func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">Any</span><span class="p">]):</span>
        <span class="o">...</span>  <span class="c1"># Code goes here</span>
    <span class="k">if</span> <span class="n">__func</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">decorator</span><span class="p">(</span><span class="n">__func</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">decorator</span>

<span class="c1"># Usage</span>
<span class="nd">@atomic</span>
<span class="k">def</span> <span class="nf">func1</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span> <span class="o">...</span>

<span class="nd">@atomic</span><span class="p">(</span><span class="n">savepoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">func2</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span> <span class="o">...</span>
</pre></div>
</div>
</section>
</section>
<section id="generic-protocols">
<h2>泛型协议<a class="headerlink" href="#generic-protocols" title="永久链接至标题">¶</a></h2>
<p>Mypy 支持泛型协议（参见 <a class="reference internal" href="protocols.html#protocol-types"><span class="std std-ref">Protocols and structural subtyping</span></a>）。有几个 <a class="reference internal" href="protocols.html#predefined-protocols"><span class="std std-ref">predefined protocols</span></a> 是泛型的，例如 <a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Iterable" title="(在 Python v3.10)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Iterable[T]</span></code></a>，你还可以定义其他的泛型协议。泛型协议大多遵循泛型类的常规规则。示例：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">TypeVar</span>
<span class="kn">from</span> <span class="nn">typing_extensions</span> <span class="kn">import</span> <span class="n">Protocol</span>

<span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Box</span><span class="p">(</span><span class="n">Protocol</span><span class="p">[</span><span class="n">T</span><span class="p">]):</span>
    <span class="n">content</span><span class="p">:</span> <span class="n">T</span>

<span class="k">def</span> <span class="nf">do_stuff</span><span class="p">(</span><span class="n">one</span><span class="p">:</span> <span class="n">Box</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">other</span><span class="p">:</span> <span class="n">Box</span><span class="p">[</span><span class="nb">bytes</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="o">...</span>

<span class="k">class</span> <span class="nc">StringWrapper</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">content</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">content</span> <span class="o">=</span> <span class="n">content</span>

<span class="k">class</span> <span class="nc">BytesWrapper</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">content</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">content</span> <span class="o">=</span> <span class="n">content</span>

<span class="n">do_stuff</span><span class="p">(</span><span class="n">StringWrapper</span><span class="p">(</span><span class="s1">&#39;one&#39;</span><span class="p">),</span> <span class="n">BytesWrapper</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;other&#39;</span><span class="p">))</span>  <span class="c1"># OK</span>

<span class="n">x</span><span class="p">:</span> <span class="n">Box</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span>
<span class="n">y</span><span class="p">:</span> <span class="n">Box</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">y</span>  <span class="c1"># Error -- Box is invariant</span>
</pre></div>
</div>
<p>根据 <span class="target" id="index-3"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0544#generic-protocols"><strong>PEP 544: 泛型协议</strong></a>， <code class="docutils literal notranslate"><span class="pre">class</span> <span class="pre">ClassName(Protocol[T])</span></code> 可以作为 <code class="docutils literal notranslate"><span class="pre">class</span> <span class="pre">ClassName(Protocol,</span> <span class="pre">Generic[T])</span></code> 的缩写。</p>
<p>泛型协议和普通泛型类之间的主要区别是，mypy 检查协议中声明的泛型类型变量的方差是否与它们在协议中使用的方式相匹配。本例中的协议被拒绝，因为类型变量 <code class="docutils literal notranslate"><span class="pre">T</span></code> 被协变地用作返回类型，但类型变量是不变量：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">TypeVar</span>
<span class="kn">from</span> <span class="nn">typing_extensions</span> <span class="kn">import</span> <span class="n">Protocol</span>

<span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">ReadOnlyBox</span><span class="p">(</span><span class="n">Protocol</span><span class="p">[</span><span class="n">T</span><span class="p">]):</span>  <span class="c1"># Error: covariant type variable expected</span>
    <span class="k">def</span> <span class="nf">content</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="p">:</span> <span class="o">...</span>
</pre></div>
</div>
<p>这个例子正确地使用了协变类型变量：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">TypeVar</span>
<span class="kn">from</span> <span class="nn">typing_extensions</span> <span class="kn">import</span> <span class="n">Protocol</span>

<span class="n">T_co</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T_co&#39;</span><span class="p">,</span> <span class="n">covariant</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">ReadOnlyBox</span><span class="p">(</span><span class="n">Protocol</span><span class="p">[</span><span class="n">T_co</span><span class="p">]):</span>  <span class="c1"># OK</span>
    <span class="k">def</span> <span class="nf">content</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">T_co</span><span class="p">:</span> <span class="o">...</span>

<span class="n">ax</span><span class="p">:</span> <span class="n">ReadOnlyBox</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span>
<span class="n">ay</span><span class="p">:</span> <span class="n">ReadOnlyBox</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">ay</span>  <span class="c1"># OK -- ReadOnlyBox is covariant</span>
</pre></div>
</div>
<p>查阅 <a class="reference internal" href="#variance-of-generics"><span class="std std-ref">泛型类型的方差</span></a> 了解更多关于 variance 的信息。</p>
<p>泛型协议也可以递归。例子：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Linked</span><span class="p">(</span><span class="n">Protocol</span><span class="p">[</span><span class="n">T</span><span class="p">]):</span>
    <span class="n">val</span><span class="p">:</span> <span class="n">T</span>
    <span class="k">def</span> <span class="nf">next</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Linked[T]&#39;</span><span class="p">:</span> <span class="o">...</span>

<span class="k">class</span> <span class="nc">L</span><span class="p">:</span>
    <span class="n">val</span><span class="p">:</span> <span class="nb">int</span>

    <span class="o">...</span>  <span class="c1"># details omitted</span>

    <span class="k">def</span> <span class="nf">next</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;L&#39;</span><span class="p">:</span>
        <span class="o">...</span>  <span class="c1"># details omitted</span>

<span class="k">def</span> <span class="nf">last</span><span class="p">(</span><span class="n">seq</span><span class="p">:</span> <span class="n">Linked</span><span class="p">[</span><span class="n">T</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="p">:</span>
    <span class="o">...</span>  <span class="c1"># implementation omitted</span>

<span class="n">result</span> <span class="o">=</span> <span class="n">last</span><span class="p">(</span><span class="n">L</span><span class="p">())</span>  <span class="c1"># Inferred type of &#39;result&#39; is &#39;int&#39;</span>
</pre></div>
</div>
</section>
<section id="generic-type-aliases">
<span id="id5"></span><h2>泛型类型别名<a class="headerlink" href="#generic-type-aliases" title="永久链接至标题">¶</a></h2>
<p>Type aliases can be generic. In this case they can be used in two ways:
Subscripted aliases are equivalent to original types with substituted type
variables, so the number of type arguments must match the number of free type variables
in the generic type alias. Unsubscripted aliases are treated as original types with free
variables replaced with <code class="docutils literal notranslate"><span class="pre">Any</span></code>. Examples (following <span class="target" id="index-1"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0484#type-aliases"><strong>PEP 484: Type aliases</strong></a>):</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">TypeVar</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Callable</span>

<span class="n">S</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;S&#39;</span><span class="p">)</span>

<span class="n">TInt</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">S</span><span class="p">]</span>
<span class="n">UInt</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="n">S</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>
<span class="n">CBack</span> <span class="o">=</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">S</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">response</span><span class="p">(</span><span class="n">query</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">UInt</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>  <span class="c1"># Same as Union[str, int]</span>
    <span class="o">...</span>
<span class="k">def</span> <span class="nf">activate</span><span class="p">(</span><span class="n">cb</span><span class="p">:</span> <span class="n">CBack</span><span class="p">[</span><span class="n">S</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">S</span><span class="p">:</span>        <span class="c1"># Same as Callable[..., S]</span>
    <span class="o">...</span>
<span class="n">table_entry</span><span class="p">:</span> <span class="n">TInt</span>  <span class="c1"># Same as tuple[int, Any]</span>

<span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">complex</span><span class="p">)</span>

<span class="n">Vec</span> <span class="o">=</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="n">T</span><span class="p">]]</span>

<span class="k">def</span> <span class="nf">inproduct</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="n">Vec</span><span class="p">[</span><span class="n">T</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="p">:</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">v</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">dilate</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="n">Vec</span><span class="p">[</span><span class="n">T</span><span class="p">],</span> <span class="n">scale</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Vec</span><span class="p">[</span><span class="n">T</span><span class="p">]:</span>
    <span class="k">return</span> <span class="p">((</span><span class="n">x</span> <span class="o">*</span> <span class="n">scale</span><span class="p">,</span> <span class="n">y</span> <span class="o">*</span> <span class="n">scale</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">v</span><span class="p">)</span>

<span class="n">v1</span><span class="p">:</span> <span class="n">Vec</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>      <span class="c1"># Same as Iterable[tuple[int, int]]</span>
<span class="n">v2</span><span class="p">:</span> <span class="n">Vec</span> <span class="o">=</span> <span class="p">[]</span>           <span class="c1"># Same as Iterable[tuple[Any, Any]]</span>
<span class="n">v3</span><span class="p">:</span> <span class="n">Vec</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># Error: Invalid alias, too many type arguments!</span>
</pre></div>
</div>
<p>Type aliases can be imported from modules just like other names. An
alias can also target another alias, although building complex chains
of aliases is not recommended – this impedes code readability, thus
defeating the purpose of using aliases.  Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">TypeVar</span><span class="p">,</span> <span class="n">Generic</span><span class="p">,</span> <span class="n">Optional</span>
<span class="kn">from</span> <span class="nn">example1</span> <span class="kn">import</span> <span class="n">AliasType</span>
<span class="kn">from</span> <span class="nn">example2</span> <span class="kn">import</span> <span class="n">Vec</span>

<span class="c1"># AliasType and Vec are type aliases (Vec as defined above)</span>

<span class="k">def</span> <span class="nf">fun</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">AliasType</span><span class="p">:</span>
    <span class="o">...</span>

<span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">NewVec</span><span class="p">(</span><span class="n">Vec</span><span class="p">[</span><span class="n">T</span><span class="p">]):</span>
    <span class="o">...</span>

<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">NewVec</span><span class="p">[</span><span class="nb">int</span><span class="p">]():</span>
    <span class="o">...</span>

<span class="n">OIntVec</span> <span class="o">=</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Vec</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>A type alias does not define a new type. For generic type aliases
this means that variance of type variables used for alias definition does not
apply to aliases. A parameterized generic alias is treated simply as an original
type with the corresponding type variables substituted.</p>
</div>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="index.html">目录</a></h3>
    <ul>
<li><a class="reference internal" href="#">泛型</a><ul>
<li><a class="reference internal" href="#defining-generic-classes">定义泛型类</a></li>
<li><a class="reference internal" href="#generic-class-internals">泛型类内部</a></li>
<li><a class="reference internal" href="#defining-sub-classes-of-generic-classes">定义泛型类的子类</a></li>
<li><a class="reference internal" href="#generic-functions">泛型函数</a></li>
<li><a class="reference internal" href="#generic-methods-and-generic-self">泛型方法和泛型 self</a></li>
<li><a class="reference internal" href="#variance-of-generic-types">泛型类型的方差</a></li>
<li><a class="reference internal" href="#type-variables-with-value-restriction">具有值限制的类型变量</a></li>
<li><a class="reference internal" href="#type-variables-with-upper-bounds">具有上界的类型变量</a></li>
<li><a class="reference internal" href="#declaring-decorators">声明装饰器</a><ul>
<li><a class="reference internal" href="#decorator-factories">装饰器工厂</a></li>
</ul>
</li>
<li><a class="reference internal" href="#generic-protocols">泛型协议</a></li>
<li><a class="reference internal" href="#generic-type-aliases">泛型类型别名</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>上一个主题</h4>
    <p class="topless"><a href="stubs.html"
                          title="上一章">Stub files</a></p>
  </div>
  <div>
    <h4>下一个主题</h4>
    <p class="topless"><a href="more_types.html"
                          title="下一章">More types</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>本页</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/generics.rst.txt"
            rel="nofollow">显示源代码</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">快速搜索</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="转向" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="总目录"
             >索引</a></li>
        <li class="right" >
          <a href="more_types.html" title="More types"
             >下一页</a> |</li>
        <li class="right" >
          <a href="stubs.html" title="Stub files"
             >上一页</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Mypy 0.940+dev.7f0839b552c99f62636632bfd44522e91b26dc54 文档</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">泛型</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; 版权所有 2016, Jukka Lehtosalo.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.4.0.
    </div>
  </body>
</html>